<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='client.failsafe' type='NEW' prio='HIGH' status="CLOSED">
   <topic>
      I_XmlBlasterAccess is the Java client side interface to xmlBlaster which supports
      polling for xmlBlaster and record/playback of messages during lost connections.
   </topic>
   <description>
      <p>
      We discuss in this requirements the strategy used by clients to connect
      to an xmlBlaster server. The same strategy is used by an xmlBlaster server
      to callback to a client.
      </p>

      <br />
      <h2>Standard client connection</h2>
      <p>
      Lets have a look at the states of a client connection without any fail save behaviour:
      </p>
      <br />
      <img src="ConnectionLifeCycleStatusDiagramNotFailSave.gif" border="0" title="Standard lifecycle of a remote connection as seen by a client" alt="Standard lifecycle of a remote connection as seen by a client" />
      <br />
      <p>
      On startup a client tries to connect to xmlBlaster and if xmlBlaster is not found we get an exception.
      Every client developer needs to code her own strategy how to poll for xmlBlaster in such a case.
      </p>

      <br />
      <h2>Fail save mode</h2>
      <p>
      In fail save mode the status diagram of a client connection (and similar a callback connection in xmlBlaster)
      is a bit more complicated, but you should remember that you have to solve these problems
      in any distributed environment, if we don't address it here you have to invent it yourself:
      </p>
      <br />
      <img src="ConnectionLifeCycleStatusDiagram.gif" border="0" title="Fail save lifecycle of a remote connection as seen by a client" alt="Fail save lifecycle of a remote connection as seen by a client" />
      <br />
      <p>
      As you can see, a client connection has three states namely <i>connected</i>, <i>polling</i> and <i>dead</i>.
      </p>
      <p>
      On startup a client tries to connect to xmlBlaster and one of the state transitions (1), (2) or (3) happens:
      The client connects successfully, the client library polls for a connection or we receive an exception.
      </p>
      <p>
      After a connection is established we may loose the connection and depending on our
      configuration parameters we start polling (4) or we give up (7), if we are tired to
      poll we give up as well (6).
      </p>
      <p>
      If we are in <i>dead</i> state, the transitions (8) and (9) show recovery possibilities.
      We could change the configuration in <i>dead</i> state, for example
      we could supply another address to find xmlBlaster. Note that this feature is
      currently NOT implemented (marked with blue color).
      </p>
      <p>
      The method names (marked green in the drawing) are events which the client developer
      may listen on to do specific handling depending on the situation.
      </p>

      <br />
      <h2>
      What is a <b>pubSessionId</b>?
      </h2>
      <p>
      Every client which connects to xmlBlaster needs to supply a login name and optionally a public session identifier
      which identifies the login session. The session identifier is <i>public</i> as everybody may see it, in contrast
      there is private session id as well (which is generated by xmlBlaster) which is secret as anybody having this
      secret session ID could kidnap the connection.
      </p>
      <p>
      The following figure shows the session naming conventions.
      </p>
      <br /><a NAME="naming"></a>
      <img src="SessionNamingConvention.gif" border="0" title="Session naming convention" alt="Session naming convention" />
      <br />
      <p>
      A client which wants to login to xmlBlaster needs at least a <i>subjectId</i>. The
      <i>subjectId</i> is a login name which must be unique in a cluster. You may not
      choose '_', ':' or '/' characters in your <i>subjectId</i>.
      </p>
      <p>
      The public session identifier (<i>pubSessionId</i>) identifies every login session
      of a specific user. The scope of a <i>pubSessionId</i> is the <i>subjectId</i> - so a client
      with another login name may have the same public session ID.<br />
      The <i>pubSessionId</i> is an integer, negative numbers are reserved for xmlBlaster generated
      <i>pubSessionId</i> whereas a client may decide to choose a well known <i>pubSessionId</i>
      itself which must be a positive integer.
      </p>
      <p>
      Examples for valid <i>relative names</i>:
      </p>
      <pre>
   joe                  // xmlBlaster generates a negative pubSessionId for us
   jack@xy.com/4        // the user 'jack@xy.com' wants to (re)connect to session 4
   averell/-2           // the second session of 'averell' (pubSessionId was generated by xmlBlaster)
      </pre>
      <p>
      Note that the client administrator needs to take care if it manages the pubSessionId himself.
      If he by mistake starts two clients with the same <i>relative name</i> they operate on the
      same server side session object instance and may produce unpredictable results.
      </p>

      <br />
      <h2>
      Client connection scenarios in a cluster environment
      </h2>
      <p>
      The following figure illustrates typical environments where a client must
      find its server and recover failsafe from lost connections.
      </p>
      <br />
      <img src="FailsaveConnectionInClusterEnvironment.gif" border="0" title="Failsave client connection in cluster environments" alt="Failsave client connection in cluster environments" />
      <br />
      <p>
      Above you see different cluster configurations which we discuss in detail later.
      The basic behind all scenarios is that the client need to more or less
      handle lost connections or lost sessions. If the client reconnects after
      failure there are two possibilities:
      </p>
      <ol>
       <li>The client gets a <b>new pubSessionId</b> which means that the session
       information of the client is lost in the server.<br />
       In this case the client it needs to reinitialize 
       all subscribes as on its startup. This sounds complicated but usually it
       is not too difficult to code an initialize method in the client which is
       invoked on startup or on reconnect.<br />
       If the xmlBlaster server would support to mirror the session information
       of clients in the cluster environment the client programmer would not
       need to remember its current subscribes.
       </li>
       <li>The client reconnects to the <b>same pubSessionId</b> which means
       it found its server side session info object again.
       This is the
       case if it found the same xmlBlaster server instance (and the session is not timed out)
       or if the xmlBlaster server instance have mirrored the session information of the client.
       </li>
      </ol>

      <p>
      Now we look at the different cluster configurations, if you have difficulties to understand
      the cluster node names you should read <i>The Lord of the Rings</i> by <i>R.R. Tolkien</i> first:
      </p>

      <h4>1. Independent server instance</h4>
      <p>
      A client needs to connect to only one xmlBlaster node, if the connection
      is lost we poll for the same server as configured on startup.
      </p>
      <p>
      </p>

      <h4>2. Cluster collective with mirrored nodes</h4>
      <p>
      The client polls for two servers, if it has connected to one it is happy.
      If the reconnect changed from say <i>sauron</i> to <i>gollum</i>
      the session information is mirrored and the client does not need to reinitialize its
      startup subscriptions.
      </p>
      <p>
      In this case the client library must support multiple server addresses.
      </p>

      <h4>3. High availability (HA) cluster with mirrored nodes</h4>
      <p>
      If you have a smart system administrator she will install
      a high availability software on your servers. This allows to reuse the
      same IP address if one of your server hardware crashes.
      From the client view it always connects to the same IP even if the hardware
      behind changed. XmlBlaster needs to run mirrored so that all xmlBlaster server nodes
      have the statefull session informations.
      Usually the HA solution uses the same harddisks (say RAID 5 hotswappable)
      which makes it easy for the xmlBlaster cluster nodes to share their persistent data.
      </p>
      <p>
      An example for a commercial HA solution is <i>ServiceGuard</i> from HP.
      </p>

      <h4>4. Master/slave cluster setup</h4>
      <p>
      In this setup no stateful session information is mirrored. If a client goes
      to the other node it needs to reinitialize its subscriptions.
      Note that all messages are available on both nodes as they operate in master/slave mode.
      </p>

      <p>
      Note: The protocol used (CORBA, RMI, XMLRPC etc.) is transparently hidden.
      See I_XmlBlasterAccess.java for a usage description and TestFailSave.java (testsuite)
      for a code example how to use it.
      </p>

      <br />
      <h2>
      Client side queuing during reconnect-polling
      </h2>
      <p>
      When a client has lost its connection to the server the Java and C++ client
      libraries support to a certain grade a client side queuing of messages from the client.
      The following table lists the features for queuing tailback messages.
      </p>
      <table border="1">
         <tr>
            <th>Method</th>
            <th>Priority</th>
            <th>Comment</th>
            <th>Java</th>
            <th>C++</th>
         </tr>

         <tr>
            <td>connect</td>
            <td>MAX</td>
            <td>A connection request is queued depending on the client configuration, see
            the above state charts about the connect() behavior</td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>publish</td>
            <td>any</td>
            <td>publish() invocation messages are queued as is.
            The key oid is generated if none is given by the client library
            as a combination of the <i>relative address</i> and a <i>JVM/process unique timestamp</i>
            and returned for the publish() invocation (faked return)<br />
            An example for a generated key oid is <i>gen:joe/2:345212004</i></td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>subscribe</td>
            <td>NORM</td>
            <td>subscribe() requests can be queued.
            The subscriptionId is generated by the client library
            as a combination of the <i>relative address</i> and a <i>JVM/process unique timestamp</i>
            and returned by the subscribe() invocation (faked return)<br />
            An example for a generated subscriptionId is <i>__subId:joe/2:345212004</i></td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
            <td><img src="no.gif" border="0" alt="no" /></td>
         </tr>

         <tr>
            <td>update</td>
            <td>any</td>
            <td>This is solved on server side</td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>get</td>
            <td>-</td>
            <td>get() invocations are synchronous and <b>can't</b> be queued,
            an exception is thrown if you try to invoke get() without a server connection.</td>
            <td><img src="no.gif" border="0" alt="no" /></td>
            <td><img src="no.gif" border="0" alt="no" /></td>
         </tr>

         <tr>
            <td>unSubscribe</td>
            <td>NORM</td>
            <td>unSubscribe() requests can only be queued if they contain
            a subscriptionId which we can use for the faked return values.
            If the unSubscribe contains a XPath query or message key oid
            an exception is thrown.<br />
            Note that you can't trust the returned information in this case.
            </td>
            <td>(<img src="ok.gif" border="0" alt="yes" />)</td>
            <td><img src="no.gif" border="0" alt="no" /></td>
         </tr>

         <tr>
            <td>erase</td>
            <td>MIN</td>
            <td>erase() requests can only be queued if they contain
            exact key oids which we can use for the faked return values.
            If the erase contains an XPath query
            an exception is thrown.<br />
            Note that you can't trust the returned information in this case.</td>
            <td>(<img src="ok.gif" border="0" alt="yes" />)</td>
            <td><img src="no.gif" border="0" alt="no" /></td>
         </tr>

         <tr>
            <td>disconnect</td>
            <td>MIN</td>
            <td>A disconnect can be queued as it returns void.
            Note that disconnect messages are never persistent to avoid
            an unexpected disconnect if a client restarts (with same public session ID)
            and there is a persistent disconnect in the client side tail back queue.</td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
            <td><img src="no.gif" border="0" alt="no" /></td>
         </tr>

      </table>
      <p>
      The Java client queuing framework supports persistent messages and supports swapping for huge message amount.
      On client crash the persistent messages are recovered.
      </p>
      <p>
      The C++ queuing framework is memory based only.
      If the C++ client is crashing and in tailback mode the messages are lost.
      </p>
      <p>
      Publish and update messages are priorized in the queue sorting as configured by the publisher.
      The priority of a connect() request is always highest whereas erase() and disconnect() has lowest priority.
      The other requests have norm priority.
      </p>
      <p>
      On demand a client can register a local callback listener to receive the real
      return values as soon as the connection is established and the tailback messages
      are flushed to the server.
      </p>
   </description>
   <example lang="Java">
      <![CDATA[
// Example with default fail save settings,
// you can change these on command line or in a property file.
// See configuration section below

import org.xmlBlaster.client.I_ConnectionStateListener;
import org.xmlBlaster.util.dispatch.ConnectionStateEnum;
import org.xmlBlaster.client.I_XmlBlasterAccess;
import org.xmlBlaster.client.I_ConnectionHandler;
...

con.registerConnectionListener(new I_ConnectionStateListener() {
      
      public void reachedAlive(ConnectionStateEnum oldState,
                               I_ConnectionHandler connectionHandler) {
         conRetQos = connectionHandler.getConnectReturnQos();
         log.info(ME, "I_ConnectionStateListener: We were lucky, connected to " +
                      glob.getId() + " as " + conRetQos.getSessionName());
         // we can access the queue via connectionHandler and for example erase the entries ...
      }
      public void reachedPolling(ConnectionStateEnum oldState,
                                 I_ConnectionHandler connectionHandler) {
         log.warn(ME, "I_ConnectionStateListener: No connection to " +
                      glob.getId() + ", we are polling ...");
      }
      public void reachedDead(ConnectionStateEnum oldState,
                              I_ConnectionHandler connectionHandler) {
         log.warn(ME, "I_ConnectionStateListener: Connection to " +
                      glob.getId() + " is DEAD");
      }
   });

ConnectReturnQos conRetQos = con.connect(qos, this);

log.info(ME, "Connected to xmlBlaster.");
...
      ]]>
   </example>

   <example lang="Java">
      <![CDATA[
import org.xmlBlaster.util.qos.address.Address;

// Example with hard coded fail save settings
// Here the callback methods are not shown
try {
   con = glob.getXmlBlasterAccess(); // Find orb

   ConnectQos connectQos = new ConnectQos(glob, loginName, passwd);

   // Setup fail save handling ...
   Address addressProp = new Address(glob);
   addressProp.setDelay(4000L);      // retry connecting every 4 sec
   addressProp.setRetries(-1);       // -1 == forever
   addressProp.setPingInterval(0L);  // switched off
   addressProp.setMaxEntries(1000);      // queue up to 1000 messages
   con.registerConnectionListener(this);

   connectQos.setAddress(addressProp);

   // and do the login ...
   con.connect(connectQos, this);  // Login to xmlBlaster, register for updates
}
catch (XmlBlasterException e) {
      Log.warn(ME, "setUp() - login failed");
      fail("setUp() - login faile");
}
 
      ]]>
   </example>

   <example lang="Java" type="HTML">
    <p id="play">
    Here are some command line examples which you can use to play and
    test reconnecting to a same session without loosing the subscriptions.
    Messages published during the subscriber is offline are 
    </p>
    <pre>
// set your CLASSPATH to xmlBlaster.jar

// Start the server, type 'd' to get an internal dump:

java org.xmlBlaster.Main

// Start a publisher in interactive mode (more options are written out to play with):

java javaclients.HelloWorldPublish -interactive true -numPublish 10 -oid Hello -persistent true

// Start a subscriber in interactive mode (more options are written out to play with):

java javaclients.HelloWorldSubscribe -session.name joeSubscriber/5 -oid Hello -dispatch/callback/retries -1

// - Now you can kill 'HelloWorldSubscribe' (without unSubscribe/disconnect)
// - Publish some messages with the still running 'HelloWorldPublish'
// - Restart 'HelloWorldSubscribe' and you should receive the queued messages without
//   subscribing again.
// - Type 'd' in the server console again and look at the dump
    </pre>
    <p>
    Note the command line settings of <i>HelloWorldSubscribe</i>, we have set <i>-dispatch/callback/retries -1</i>
    which tells xmlBlaster to poll forever if the clients callback server is not reached.
    If you don't do that, the default is for xmlBlaster to kill the clients session if the
    callback server is not responding on pings anymore.
    </p>
    <p>
    The other important setting is <i>-session.name joeSubscriber/5</i>, we have not only passed
    a subjectId (loginName) <i>joeSubscriber</i> but also forced to use the publicSessionId <i>5</i>.
    This way we can always reconnect to the session <i>joeSubscriber/5</i> as long as this session
    is still alive.
    </p>
   </example>

   <configuration where="server">
      <p>
      These parameters allow to configure the clients fail save behavior.
      </p>
      <p>
      Example:
      <pre>java HelloWorld4 -queue/callback/maxEntries 20000 -retries -1 -session.name joe/2</pre>
      </p>
      <table border="1">
         <tr>
            <th>Property</th>
            <th>Default / Example</th>
            <th>Description</th>
            <th>Impl</th>
         </tr>

         <tr>
            <td>pingInterval</td>
            <td>10000</td>
            <td>Ping every given milliseconds if xmlBlaster connection is OK</td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>retries</td>
            <td>-1 (forever)</td>
            <td>How often to retry to establish a new connection to xmlBlaster
                on failure.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>delay</td>
            <td>4000</td>
            <td>Delay between connection retries in milliseconds<br />
                A delay value > 0 switches fails save mode on, 0 switches it off</td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
         
         <tr>
            <td>queue/connection/maxEntries</td>
            <td>1000</td>
            <td>The maximum allowed number of messages in the client side queue<br />
                0 switches recording of invocations (tail back messages) off.<br />
                -1 sets it to unlimited.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>dispatch/callback/retries</td>
            <td>0</td>
            <td>How often the xmlBlaster server shall retry to reach our client side callback server
                on failure. Defaults to 0, which destroys the clients session if the
                clients callback server is not reachable. -1 sets it to try forever and
                preserve the client session even if the client is offline.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>dispatch/callback/delay</td>
            <td>60000</td>
            <td>See <i>delay</i> above, but this value configures the delay of xmlBlaster
            server callback framework.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>queue/callback/maxEntries</td>
            <td>1000</td>
            <td>The maximum allowed number of messages in the server side callback queue if this client<br />
                -1 sets it to unlimited.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
      </table>
   </configuration>

   <see type="REQ">queue</see>
   <see type="REQ">client.failsafe.ping</see>
   <see type="REQ">cluster</see>
   <see type="REQ">util.recorder</see>
   <see type="REQ">util.recorder.persistence</see>
   <see type="API">org.xmlBlaster.client.I_XmlBlasterAccess</see>
   <author>xmlBlaster@marcelruff.info</author>
   <hacker>xmlBlaster@marcelruff.info</hacker>
   <date>2000 02 23</date>
   <revision>$Revision: 1.11 $</revision>
   <testcase status="CLOSED">
      <name>-</name>
      <comment>-</comment>
      <test tool="SUITE">org.xmlBlaster.test.authenticate.TestSessionReconnect</test>
      <test tool="SUITE">org.xmlBlaster.test.qos.TestFailSave</test>
      <test tool="SUITE">org.xmlBlaster.test.qos.TestInvocationRecorder</test>
      <test tool="SUITE">org.xmlBlaster.test.qos.TestFailSaveAsync</test>
      <test tool="SUITE">org.xmlBlaster.test.classtest.InvocationRecorderTest</test>
   </testcase>
</requirement>

