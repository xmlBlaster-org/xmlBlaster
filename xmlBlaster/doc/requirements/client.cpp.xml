<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">


<requirement id='client.cpp' type='NEW' prio='HIGH' status='CLOSED'>
   <topic>
      XmlBlaster provides a complete client library written in c++.
   </topic>
   <description>
     <p>
     For c++ client applications you can use the class XmlBlasterAccess which provides access to
     xmlBlaster in an easy way. All invocations to xmlBlaster are done by passing objects to the 
     dispatcher.
     </p>
     <p>
     <ul>
     <li>for connecting read the <a href="interface.connect.html">connect interface</a></li>
     <li>for disconnecting read the <a href="interface.disconnect.html">disconnect interface</a></li>
     <li>for erasing read the  <a href="interface.erase.html">erase interface</a></li>
     <li>for getting read the  <a href="interface.get.html">get interface</a></li>
     <li>for publishing read the  <a href="interface.publish.html">publish interface</a></li>
     <li>for subscribing read the  <a href="interface.subscribe.html">subscribe interface</a></li>
     <li>for unsubscribing read the  <a href="interface.unSubscribe.html">unSubscribe interface</a></li>
     <li>for callbacks read the  <a href="interface.update.html">update interface</a></li>
     </ul>
     For the invocation on the qos and key objects please refere to the APIs for 
     <ul>
     <li>org::xmlBlaster::util::qos (for ConnectQos)</li>
     <li>org::xmlBlaster::client::qos</li>
     <li>org::xmlBlaster::client::key</li>
     </ul>
     </p>
   </description>
   <example lang="CPP">
   <pre>

<![CDATA[
#include <client/XmlBlasterAccess.h>
#include <util/XmlBlasterException.h>
#include <util/Global.h>
#include <util/Log.h>
#include <util/PlatformUtils.hpp>
#include <util/Timestamp.h>

using namespace std;
using namespace org::xmlBlaster::util;
using namespace org::xmlBlaster::client;
using namespace org::xmlBlaster::client::qos;
using namespace org::xmlBlaster::client::key;
using namespace org::xmlBlaster;

class HelloWorld2 : public I_Callback,          // for the asynchroneous updates
                    public I_ConnectionProblems // for notification of connection problems when failsafe
{
private:
   string  ME;                                  // the string identifying this class when logging
   Global& global_;                            
   Log&    log_;                                // the reference to the log object for this instance

public:
   HelloWorld2(Global& glob) 
         : ME("HelloWorld2"),
           global_(glob), 
                 log_(glob.getLog("demo"))      // all logs written in this class are written to the
   {                                            // log channel called 'demo'. To see the traces of this
   }                                            // channel invoke -trace[demo] true on the command line,
                                                // then it will only switch on the traces for the demo channel

   virtual ~HelloWorld2()                       // the constructor does nothing for the moment
   {
   }


   bool reachedAlive(StatesEnum /*oldState*/, I_ConnectionsHandler* /*connectionsHandler*/)
   {
      log_.info(ME, "reconnected");
      return true;
   }

   void reachedDead(StatesEnum /*oldState*/, I_ConnectionsHandler* /*connectionsHandler*/)
   {
      log_.info(ME, "lost connection");
   }

   void reachedPolling(StatesEnum /*oldState*/, I_ConnectionsHandler* /*connectionsHandler*/)
   {
      log_.info(ME, "going to poll modus");
   }

   void execute()
   {
      try {
         XmlBlasterAccess con(global_);
         con.initFailsafe(this);

         // Creates a connect qos with the user 'joe' and the password 'secret'
         ConnectQos qos(global_, "joe", "secret");
         log_.info(ME, string("connecting to xmlBlaster. Connect qos: ") + qos.toXml());

                                 // connects to xmlBlaster and gives a pointer to this class to tell which update method to invoke
                                 // when callbacks come from the server.
         ConnectReturnQos retQos = con.connect(qos, this);  // Login to xmlBlaster, register for updates
         log_.info(ME, "successfully connected to xmlBlaster. Return qos: " + retQos.toXml());

                                 // subscribe key. By invoking setOid you implicitly choose the 'EXACT' mode. If you want to 
                                 // subscribe with XPATH use setQueryString instead.
         SubscribeKey subKey(global_);
         subKey.setOid("HelloWorld2");
         SubscribeQos subQos(global_);
         log_.info(ME, string("subscribing to xmlBlaster with key: ") + subKey.toXml() + " and qos: " + subQos.toXml());

         SubscribeReturnQos subRetQos = con.subscribe(subKey, subQos);
         log_.info(ME, string("successfully subscribed to xmlBlaster. Return qos: ") + subRetQos.toXml());

                                 // publish a message with the oid 'HelloWorld2'
         PublishQos publishQos(global_);
         PublishKey publishKey(global_);
         publishKey.setOid("HelloWorld2");
         MessageUnit msgUnit(publishKey, string("Hi"), publishQos);
         log_.info(ME, string("publishing to xmlBlaster with message: ") + msgUnit.toXml());
         PublishReturnQos pubRetQos = con.publish(msgUnit);
         log_.info(ME, "successfully published to xmlBlaster. Return qos: " + pubRetQos.toXml());
         try {
            Thread::sleepSecs(1);
         }
         catch(XmlBlasterException e) {
            cout << e.toXml() << endl;
         }

         // now an update should have come. Its time to erase the message (otherwise you would get directly
         // an update the next time you connect to the same xmlBlaster server. Specify which messages you
         // want to erase. Note that you will get an update with the status of the UpdateQos set to 'ERASED'.
         EraseKey eraseKey(global_);
         eraseKey.setOid("HelloWorld2");
         EraseQos eraseQos(global_);
         log_.info(ME, string("erasing the published message. Key: ") + eraseKey.toXml() + " qos: " + eraseQos.toXml());
         vector<EraseReturnQos> eraseRetQos = con.erase(eraseKey, eraseQos);
         for (size_t i=0; i < eraseRetQos.size(); i++ ) {
            log_.info(ME, string("successfully erased the message. return qos: ") + eraseRetQos[i].toXml());
         }

         log_.info(ME, "going to sleep for one minute");
         org::xmlBlaster::util::thread::Thread::sleep(60000);

         DisconnectQos disconnectQos(global_);
         con.disconnect(disconnectQos);
      }
      catch (XmlBlasterException e) {
         cout << e.toXml() << endl;
      }
   }

   string update(const string& sessionId, UpdateKey& updateKey, void *content, long contentSize, UpdateQos& updateQos)
   {
      log_.info(ME, "update: key: " + updateKey.toXml());
      log_.info(ME, "update: qos: " + updateQos.toXml());
      return "";
   }

};

/**
 * Try
 * <pre>
 *   java HelloWorld2 -help
 * </pre>
 * for usage help
 */
int main(int args, char ** argv)
{
   XMLPlatformUtils::Initialize();
   Global& glob = Global::getInstance();
   glob.initialize(args, argv);
// XmlBlasterConnection::usage();
//   glob.getLog().info("HelloWorld2", "Example: java HelloWorld2\n");

   HelloWorld2 hello(glob);
   hello.execute();
   return 0;
}

]]>

   </pre>
   </example>

   <configuration where="client">
      <p>
      These configurations are tested:
      </p>
      <table border="1">
       <tr>
       <th>No.</th>
       <th>OS</th>
       <th>Compiler</th>
       <th>xmlBlaster</th>
       <th>Protocol library</th>
       <th>XML library</th>
       <th>Date</th>
       <th>Author</th>
       <th>Comment</th>
       </tr>

       <tr>
       <td>1</td>
       <td>WindowsXP</td>
       <td>VC++ 7</td>
       <td><a href="http://www.xmlBlaster.org/xmlBlaster/CHANGES">0.842</a></td>
       <td>CORBA: <a href="http://www.cs.wustl.edu/~schmidt/TAO.html">ACE/TAO 1.2.2 or ACE 5.3/TAO 1.3</a></td>
       <td><a href="http://xml.apache.org">XERCES C++ 2.2</a></td>
       <td>2003-02-14</td>
       <td><a href="mailto:mjhn@bigpond.net.au">Martin</a>, <a href="mailto:xmlBlaster@marcelruff.info">Marcel</a></td>
       <td>Edit <a href="http://www.xmlBlaster.org/xmlBlaster/build.properties">build.properties</a> and use <a href="http://www.xmlBlaster.org/xmlBlaster/build.xml">xmlBlaster/build.xml</a> to compile</td>
       </tr>

       <tr>
       <td>2</td>
       <td>WindowsXP</td>
       <td>VC++ 7</td>
       <td><a href="http://www.xmlBlaster.org/xmlBlaster/CHANGES">0.842</a></td>
       <td>CORBA: <a href="http://www.mico.org">mico 2.3.8</a></td>
       <td><a href="http://xml.apache.org">XERCES C++ 1.7</a></td>
       <td>2003-02-14</td>
       <td><a href="mailto:xmlBlaster@marcelruff.info">Marcel</a></td>
       <td>Edit <a href="http://www.xmlBlaster.org/xmlBlaster/build.properties">build.properties</a> and use <a href="http://www.xmlBlaster.org/xmlBlaster/build.xml">xmlBlaster/build.xml</a> to compile</td>
       </tr>

       <tr>
       <td>3</td>
       <td>Linux 2.4.18</td>
       <td><a href="http://www.gnu.org/software/gcc/gcc.html">g++</a> 3.2</td>
       <td><a href="http://www.xmlBlaster.org/xmlBlaster/CHANGES">0.842</a></td>
       <td>CORBA: <a href="http://www.cs.wustl.edu/~schmidt/TAO.html">ACE 5.3 and TAO 1.3</a></td>
       <td><a href="http://xml.apache.org">XERCES C++ 2.2</a></td>
       <td>2003-02-14</td>
       <td><a href="mailto:laghi@swissinfo.org">Michele</a>, <a href="mailto:xmlBlaster@marcelruff.info">Marcel</a></td>
       <td>Edit <a href="http://www.xmlBlaster.org/xmlBlaster/build.properties">build.properties</a> and use <a href="http://www.xmlBlaster.org/xmlBlaster/build.xml">xmlBlaster/build.xml</a> to compile</td>
       </tr>

       <tr>
       <td>3</td>
       <td>Linux 2.4.4 and 2.4.18</td>
       <td><a href="http://www.gnu.org/software/gcc/gcc.html">g++</a> 2.95.2 and 3.2</td>
       <td><a href="http://www.xmlBlaster.org/xmlBlaster/CHANGES">0.842</a></td>
       <td>CORBA: <a href="http://www.mico.org/">mico 2.3.7</a></td>
       <td><a href="http://xml.apache.org">XERCES C++ 2.2</a></td>
       <td>2003-02-14</td>
       <td><a href="mailto:laghi@swissinfo.org">Michele</a>, <a href="mailto:xmlBlaster@marcelruff.info">Marcel</a></td>
       <td>Edit <a href="http://www.xmlBlaster.org/xmlBlaster/build.properties">build.properties</a> and use <a href="http://www.xmlBlaster.org/xmlBlaster/build.xml">xmlBlaster/build.xml</a> to compile</td>
       </tr>
      </table>
      <p>
       For compilation options please use
      </p>
<pre>
   build.sh cpp     compiles client lib and testsuite on UNIX
   build.bat cpp    compiles client lib and testsuite on Windows

   build.sh usage   show other compile options
</pre>
<p>
Compilation with VC 6 will fail.
</p>
<p>
The source code is already prepared for other corba implementors such as
</p>
<ol>
  <li>ORBACUS</li>
  <li>ORBIX</li>
  <li>OMNIORB</li>
</ol>
<p>
but the current status of the library has not been tested against these orbs.
See <a href="http://www.xmlBlaster.org/xmlBlaster/src/c++/client/protocol/corba/CompatibleCorba.h">CompatibleCorba.h</a> for a current list.
</p>
<p>
Please <a href="mailto:xmlBlaster-devel@xmlBlaster.org">let us know</a> if you successfully compiled and ran the testsuite with other combinations.
Particularly interesting it would be the INTEL compiler on Linux and Windows and Solaris with the GCC or the Workshop Compiler. 
</p>
   </configuration>

   <see type="REQ">client.cpp.precondition</see>

<!--   <see type="REQ">cluster</see> -->
   <author><a href="mailto:laghi@swissinfo.org">Michele Laghi</a></author>
   <date>2003 01 15</date>
   <revision>$Revision: 1.3 $</revision>
</requirement>

