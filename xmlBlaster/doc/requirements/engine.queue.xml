<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='engine.queue' type='NEW' prio='HIGH' status="INWORK">
   <topic>XmlBlaster has a sophisticated message queueing engine</topic>
   <description>
      <p>
      Message are queued only when necessary. This occurs typically on messages which
      need to be sent back to clients:
      </p>
      <img src="MsgQueue.gif" border="0" title="XmlBlaster Message Queue" alt="Overview of the internal message queue framework" />
      <p>
      Queue Features:
      </p>
      <ul>
      <li>High performing and thread safe<br />
      The queue is based on a sorted bounded buffer from Doug Lea.
      It is higher performing than a thread safe java.util collection TreeSet,
      consuming 100 mirco seconds instead of 200 micro seconds for the latter
      to insert and remove one message.
      </li>
      <li>Priority support<br />
      The priority for messages can be specified when publishing.
      The standard value is 5, a value of 9 has highest priority, whereas 0 is slowest.
      </li>
      <li>Guarantee sequence<br />
      The sequence of incoming messages is recorded with a unique timestamp.
      On delivery this sequence is guaranteed to be equal.
      Different message priorities reorder the sequence of message delivery, since
      priority is a higher sort criteria than the incoming timestamp.
      </li>
      <li>Bounded (max size)<br />
      Every queue has a maximum size. The maximum boundary is adjustable
      as the number of entries in the queue or as maximum memory consumption.
      On queue overflow a "dead letter" is published.
      A MsgQueue can be configured to support 'falling
      through'. In this case the oldest message is removed when the queue is full and
      a new message arrives.
      </li>
      <li>Dead letter<br />
      On queue overflow a "dead letter" is published, containing the lost message.
      Interested exception handlers clients can subscribe to "__sys__deadLetter" messages to
      receive them and react accordingly. A logging entry is written in such a case to
      the servers log file. 
      </li>
      <li>Queue types<br />
      A queue is installed on the fly when needed. If a message destination is
      not reachable, a queue is created to hold messages addressed for this destination.
      Two message queue types are created on login and one for each published callback address.
      <ol>
         <li>SessionQueue (<i>SessionID:</i>)<br />
         This queue is created on login and destroyed on logout.
         It can be used as the ReplyTo address for sent messages.
         This is the default callback for session based subscriptions without a specified callback in the login QoS.
         </li>
         <li>SubjectQueue (<i>UserID:</i>)<br />
         This queue is created on login if not existing beforehand.
         The queue is named similar to the login name of the client.
         It may remain living after logout, or may be created before login if
         a PtP message addresses it.
         This is the default callback for login name based (durable) subscriptions without a specified callback in its QoS.
         It is destroyed when the queue expires.
         The specified callback server of the SessionQueue is used if not otherwise specified in the login QoS.
         Every message from this queue is delivered to all current sessions of the user. On multiple logins,
         the same message is delivered multiple times.
         </li>
         <li>UnrelatedQueue (<i>CbID:</i>)<br />
         This are queues which are created for subscribes which expressly states a callback
         address in its QoS. It can be a delegated subscribe (e.g. for a dumb toaster).
         This is a durable subscription outliving the logout of its creator (if not otherwise configured).
         It is destroyed when the queue expires.
         Subscribes without callbacks specified in its QoS, are using as a default the callback address of the SessionQueue
         or the SubjectQueue if the first is not available.
         </li>
      </ol>
      </li>
      <li>Zero or one callback address<br />
      Every message queue has zero or one callback addresses associated:
      The SessionQueue and the UnrelatedQueue have exactly one, the SubjectQueue 
      has one or zero (if not logged in).
      </li>
      <li>Synchronous browsing<br />
      A message queue may be browsed with the synchronous get() method.
      </li>
      <li>Sequence on XPath subscription<br />
      A subscription with XPath may collect many messages with one query.
      The sequence of those message is guaranteed (priority and timestamp subordering).
      </li>
      </ul>
      <p>
      </p>
   </description>
   <example lang="Java">
      <![CDATA[

      These is an example QoS of a connect() invocation:
      ==================================================

      <qos>
         ...
         <!-- default SessionQueue callback: Use CORBA to send messages back -->
         <callback type='IOR' sessionId='sd3lXjs9Fdlggh'>
            IOR:00011200070009990000....
         </callback>
      </qos>


      <qos>
         ...
         <!-- SubjectQueue callback: Use email -->
         <queue relating='subject' maxMsg='1600' expires='360000000' onOverflow='discardOldest'>
            <callback type='EMAIL'>
               et@mars.universe
            </callback>
         </queue>
      </qos>


      <qos>
         ...
         <callback type='IOR'> <!-- SessionQueue callback: Use CORBA to send messages back -->
            IOR:00011200070009990000....
            <compress type='gzip' minSize='1000' />
                      <!-- compress messages bigger 1000 bytes before sending them to me -->
            <burstMode collectTime='400' /> <!-- Collect messages for 400 milliseconds and update
                       them in one callback (burst mode) -->
         </callback>
      </qos>


      These are example QoS of subsribe() invocations:
      ================================================

      <!-- The subscribed messages are delivered via the SessionQueue of the subscriber -->
      <qos>
      </qos>

      <!-- Same as above -->
      <qos>
         <queue relating='session'/>
      </qos>

      Any other queue overwrites session delivery:

      <!-- The subscribed messages are only delivered via the SubjectQueue of the current client -->
      <qos>
         <queue relating='subject'/>
         <queue relating='subject:somebodyElse'/>
      </qos>

      <qos>
         <queue relating='unrelated' maxMsg='1000' maxSize='4000' onOverflow='deadLetter'/>
            <callback type='EMAIL'>
               et@mars.universe   <!-- Sends messages to et with specified queue attributes -->
            </callback>
         </queue>

         <callback type='EMAIL'>  <!-- callback specification is always unrelated -->
            tolkien@mars.universe <!-- Sends messages to tolkien, with default queue settings -->
         </callback>


         <callback type='IOR' sessionId='sd3lXjs9Fdlggh'> <!-- Sends message via CORBA as well -->
            IOR:00011200070009990000....
         </callback>

         <callback type='XML-RPC' sessionId='8sd3lXjspx9Fdlggh'>
            http:/www.mars.universe:8080/RPC2
         </callback>

         <!-- The session id is passed to the client callback server, he can check
              if he trusts this sender -->
      </qos>
      
      ]]>
   </example>
   <see type="API">org.xmlBlaster.engine.queue.MsgQueue</see>
   <see type="API">org.xmlBlaster.engine.callback.CbWorker</see>
   <see type="REQ">engine.callback</see>
   <see type="REQ">engine.qos.login.callback</see>
   <author>ruff@swand.lake.de</author>
   <date>2002 02 04</date>
   <revision>$Revision: 1.5 $</revision>
   <testcase status="OPEN">
      <name>-</name>
      <comment>-</comment>
      <test tool="SUITE">testsuite.</test>
   </testcase>
</requirement>

