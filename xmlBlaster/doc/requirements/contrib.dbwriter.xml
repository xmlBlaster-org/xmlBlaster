<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='contrib.dbwriter' type='NEW' prio='HIGH' status="CLOSED">
   <topic>
      DbWriter writes to a Database entries received as XmlBlaster Messages. It is the ideal sink for its counterpart DbWatcher.
   </topic>

   <description>
     <h2>DbWriter overview</h2>
     <p>
       DbWriter is a little framework of plugins which writes to a Database messages which have been published either by the DbWatcher or
       following its message content xml-syntax. 
       DbWriter is extendable through a set of plugin interfaces. For standard cases we provide useful plugins.
     </p>
     <p>
       DbWriter may be useful when running xmlBlaster to integrate legacy applications where data needs to be writter to a database.
       Typical uses are for example database partial- or complete replication with- or without modification/manipulation.
     </p>
     <p>
       The Message Content is an XML Representation of the JDBC ResultSet of a query. Its syntax if fully compatible with the syntax generated by
       the DbWatcher. In fact this interchange format is the contract between these two plugin frameworks.
       This contract is defined in <a href="http://www.xmlBlaster.org/xmlBlaster/src/java/org/xmlBlaster/contrib/dbwatcher/DbWatcherMessage.xsd">
       the DbWatchwer/DbWriter Contract XSD Schema</a>
     </p>
     <p>Now that you know what DbWriter can do for you we should look into its design.</p>

    <h2>DbWriter design</h2>
     <p>
       DbWriter makes use of a set of interfaces. Some of them are shared with the DbWatcher (as for example <tt>I_ChangePublisher</tt>, 
       <tt>I_DbPool</tt> and <tt>I_Info</tt>), 
       while others as the <tt>I_Parser</tt> and <tt>I_Writer</tt> are exclusive for the DbWriter. Additionally, to make it easier
       for the user, there is a set of info objects encapsulating the XML Message content as a set of java classes.
       These classes are defined in the <tt>info</tt> package.
     </p>
    
     <ol>
      <li><tt>I_Parser</tt><quote>How has the content of the messages to be parsed ?</quote><br />
         Normally you should not really bother for this, one single implementation should be enough for the most use cases. The default
         implementation is <tt>org.xmlBlaster.contrib.dbwriter.Writer</tt>
      </li>
    
      <li><tt>I_Writer</tt><quote>How shall the jdbc operation be performed ?</quote><br />
        There is a simple default implementation providing the basic functionality. This is the <tt>DefaultWriter</tt>. For more complex or 
        specific operations you should write your own implementation.
      </li>
     </ol>
    
    </description>

<!--
   <example lang="any" type="HTML">
     <h2 id="exampleTimestamp">Timestamp based polling example</h2>
     <p>Lets create a database table <tt>TEST_POLL</tt> which contains a <tt>TIMESTAMP</tt> column <tt>TS</tt> (tested on Oracle):</p>
   </example>

   <example lang="any" type="HTML">
     <h2 id="exampleMD5">MD5 based polling example</h2>
   </example>
-->

   <configuration where="server">
      <p>
         The plugin is configured in the <tt>xmlBlasterPlugins.xml</tt> configuration file.
         If you run DbWatcher outside of xmlBlaster the <tt>I_Info</tt> interface must return those settings.
      </p>

    <table border="1">
       <tr>
         <th>Id (name)</th>
         <th>Type</th>
         <th>Manda
         tory</th>
         <th>Default value</th>
         <th>Comment</th>
       </tr>
       <tr>
         <td>dbPool.class</td>
         <td>String</td>
         <td>yes</td>
         <td>org.xmlBlaster.contrib.db.DbPool</td>
         <td>
         Configures your implementation of interface <tt>I_DbPool</tt>.
         </td>
       </tr>
       <tr>
         <td>mom.class</td>
         <td>String</td>
         <td>yes</td>
         <td>org.xmlBlaster.contrib.MomEventEngine</td>
         <td>Configures your implementation of interface <tt>I_ChangePublisher</tt></td>
       </tr>
       <tr>
         <td>parser.class</td>
         <td>String</td>
         <td>yes</td>
         <td>org.xmlBlaster.contrib.dbwriter.SqlInfoParser</td>
         <td>Configures your implementation of interface <tt>I_Parser</tt></td>
       </tr>
       <tr>
         <td>dbWriter.writer.class</td>
         <td>String</td>
         <td>yes</td>
         <td>org.xmlBlaster.contrib.dbwriter.Writer</td>
         <td>Configures your implementation of interface <tt>I_Writer</tt></td>
       </tr>
       <tr>
         <td>jdbc.drivers</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>
         For example <tt>oracle.jdbc.driver.OracleDriver</tt>,
         the database specific driver jar file which contains the above
         class must be in the class path.
         </td>
       </tr>
       <tr>
         <td>db.url</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>
         For example <tt>jdbc:oracle:thin:@localhost:1521:orcl</tt>.
         </td>
       </tr>
       <tr>
         <td>db.user</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>
         The database user login name.
         </td>
       </tr>
       <tr>
         <td>db.password</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>
         The database password.
         </td>
       </tr>
     </table>   

    <p>If you use the default configuration for <tt>mom.class</tt>, then the following configuration attributes may/shall be used:</p>
    <table border="1">
       <tr>
         <th>Id (name)</th>
         <th>Type</th>
         <th>Manda
         tory</th>
         <th>Default value</th>
         <th>Comment</th>
       </tr>
       <tr>
         <td>mom.subscriptions</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>This is a comma separated list of labels identifying a subscription to be done. For every entry specified here, 
	     there must be a corresponding attribute mom.subscribeQos[...] and mom.subscribeKey[...]. So if you specified <tt>mom.subscriptions=someTopic</tt>,
	     then there must be an attribute <tt>mom.subscribeQos[someTopic]</tt> and an attribute <tt>mom.subscribeKey[someTopic]</tt> defined.
	 </td>
       </tr>
       <tr>
         <td>mom.subscribeKey[...]</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>This is an xml literal (better to wrap it with CDATA) describing the subscribeKey to be used for the given label.
	     This is mandatory if you specified a label in <tt>mom.subscriptions</tt>. If you don't do it, you will get an exception 
	     when initializing. For every mom.subscribeKey, there must be a mom.subscribeQos counterpart.
	 </td>
       </tr>
       <tr>
         <td>mom.subscribeQos[...]</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>This is an xml literal (better to wrap it with CDATA) describing the subscribeQos to be used for the given label.
	     This is mandatory if you specified a label in <tt>mom.subscriptions</tt>. If you don't do it, you will get an exception 
	     when initializing. For every mom.subscribeQos, there must be a mom.subscribeKey counterpart.
	 </td>
       </tr>

       <tr>
         <td>mom.connectQos</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>This is an xml literal (better to wrap it with CDATA) describing the connectQos. If you specify null here, then 
	     the connectQos will be constructed out of other configuration attributes.
	     <tt>maxSession</tt> is set to whatever configured in <tt>mom.maxSessions</tt>, retries for connection and callback
	     are set to -1 (failsafe mode), <tt>dispatcherPlugin</tt> (if any) to what specified by <tt>mom.dispatcherPlugin</tt>.
	     The session timeout is set to zero (will never die).
	 </td>
       </tr>
       <tr>
         <td>mom.loginName</td>
         <td>String</td>
         <td>no</td>
         <td>dbWriter/1</td>
         <td>The loginName or session name to be used.</td>
       </tr>
       <tr>
         <td>mom.password</td>
         <td>String</td>
         <td>no</td>
         <td>secret</td>
         <td>The password to use for this mom connection.</td>
       </tr>
       <tr>
         <td>mom.dispatcherPlugin</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>The dispatcher plugin name to use (type/version)</td>
       </tr>
       <tr>
         <td>mom.maxSessions</td>
         <td>int</td>
         <td>no</td>
         <td>100</td>
         <td>The maximum number of sessions to allow for this subject.</td>
       </tr>
     </table>   
   </configuration>

   <todo type="HTML">
   <p>Port testsuite to run with HSQLDB and MS-SQLServer, currently the SQL statements from the testsuite
   are Oracle specific, currently you need a running Oracle, a running xmlBlaster and start the tests separately:</p>
   <p>
   <tt>java -Ddb.password=secret junit.swingui.TestRunner -noloading org.xmlBlaster.test.contrib.dbwatcher.TestResultSetToXmlConverter</tt>
   </p>
   <p>
   <tt>java -Ddb.password=secret junit.swingui.TestRunner -noloading org.xmlBlaster.test.contrib.dbwatcher.TestTimestamp</tt>
   </p>

   <p>Add other <tt>I_ChangeDetector</tt> plugins which scale better for tables with huge amount of entries.
   </p>
   </todo>

   <see type="API">org.xmlBlaster.contrib.dbwriter.DbWriter</see>
   <see type="API">org.xmlBlaster.contrib.dbwriter.I_Parser</see>
   <see type="API">org.xmlBlaster.contrib.dbwriter.I_Writer</see>
   <see type="API">org.xmlBlaster.contrib.dbwriter.info.SqlInfo</see>
   <see type="API">org.xmlBlaster.contrib.dbwatcher.DbWatcher</see>
   <see type="REQ">engine.runlevel</see>
   <see type="REQ">contrib.dbwatcher</see>
   <author>laghi@swissinfo.org</author>
   <hacker>laghi@swissinfo.org</hacker>
   <date>2005 12 19</date>
   <revision>$Revision$</revision>
   <testcase status="CLOSED">
      <name>-</name>
      <comment>-</comment>
      <test tool="SUITE">org.xmlBlaster.test.contrib.dbwriter.TestRecordParsing</test>
   </testcase>
</requirement>

