<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='contrib.dbwatcher' type='NEW' prio='HIGH' status="CLOSED">
   <topic>
      DbWatcher polls a database for changes and publishes those to xmlBlaster.
   </topic>

   <description>
   <h2>DbWatcher overview</h2>
   <p>
   DbWatcher is a little framework of plugins which detects changes on a database table,
   queries the changes, formats them as a XML message and publishes them to xmBlaster.
   DbWatcher is ready to go, you only set some configuration variables in <tt>xmlBlasterPlugins.xml</tt>
   and on next xmlBlaster startup the configured database table is observed.<br />
   DbWatcher is extendable through a set of plugin interfaces. For standard
   cases we provide useful plugins.
   </p>
   <p>
   DbWatcher may be useful when running xmlBlaster to integrate legacy applications
   where often many code segments update a database and other code segments or
   foreign applications need to know about the changes.
   </p>
   <p>
   With the delivered JDBC ResultSet to XML converter plugin a typical
   database change message looks like this:
   </p>
<pre>
&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
 &lt;desc>
  &lt;command>INSERT&lt;/command>
  &lt;ident>EDDI&lt;/ident>
  &lt;colname type='DATE' isNullable='0'>DATUM&lt;/colname>
  &lt;colname type='NUMBER' precision='11' scale='0' signed='false'>
              CPU&lt;/colname>
  &lt;colname type='VARCHAR2' precision='20' isReadOnly='true'>COL1&lt;/colname>
  &lt;colname table='OMZ' schema='AA' catalog='CAT' type='VARCHAR2'
              precision='10'>ICAO_ID&lt;/colname>
 &lt;/desc>
 &lt;row num='0'>
  &lt;col name='DATUM'>2005-01-05 15:52:06.0&lt;/col>
  &lt;col name='CPU'>238333&lt;/col>
  &lt;col name='COL1'>&lt;![CDATA[&lt;Bla]]&gt;&lt;/col>
  &lt;col name='ICAO_ID'>EDDI&lt;/col>
  &lt;attr name='LR'>SRANIL&lt;/attr>
  &lt;attr name='SUBNET_ID'>TCP&lt;/attr>
 &lt;/row>
 &lt;row num='1'>
  &lt;col name='DATUM'>2005-01-05 15:52:07.0&lt;/col>
  &lt;col name='CPU'>238340&lt;/col>
  &lt;col name='COL1' encoding='base64'>QmxdXT5CbA==&lt;/col>
  &lt;col name='ICAO_ID'>EDDI&lt;/col>
 &lt;/row>
&lt;/sql>
</pre>
  <p>
  The generated message has a header tag &lt;desc> which contains the meta information
  of the delivered data. This is self explaining, the &lt;ident> tag delivers the changed
  value of the database table column <tt>ICAO_ID</tt> which caused the change message.<br />
  The &lt;col> tags deliver the current columns value of a database table row. If
  they contain characters which harm XML wellformedness they are enclosed with a CDATA
  section. On seldom cases where this protection is not sufficient the column is BASE64 encoded.<br />
  Additionally, you can configure a transformer which does some use case specific
  transformations on the data an delivers the result with &lt;attr> tags.
  </p>
  <p>
  Now that you know what DbWatcher can do for you we should look into its design.
  </p>


  <h2>DbWatcher design</h2>
  <p>
  DbWatcher consists of a set of Interfaces which allows any thinkable customization.
  It is easily possible to run DbWatcher outside from xmlBlaster as a standalone
  program or even without any dependency on xmlBlaster.
  </p>
  <ol>
   <li><tt>I_ChangePublisher</tt><quote>Into which data sink to send the data?</quote><br />
   This is the MoM interface and we provide a <tt>XmlBlasterPublisher</tt> plugin.
   You can easily write a JMS plugin to send the changes to a JMS provider
   or a file system plugin to dump the message on harddisk.
   </li>

   <li><tt>I_DataConverter</tt><quote>How shall the message be formatted?</quote><br />
   We provide a <tt>ResultSetToXmlConverter</tt> plugin which produces the above shown XML message.
   </li>

   <li><tt>I_AttributeTransformer</tt><quote>Are there any additional attributes to be added to the XML dump?</quote><br />
   Here we provide nothing, you can add one yourself if you need to add specific &lt;attr> tags.
   This possibility is offered by our <tt>ResultSetToXmlConverter</tt> to extend the XML message.
   </li>

   <li><tt>I_ChangeDetector</tt><quote>How do we detect changes on the databse</quote><br />
   We provide two plugins here.<br />
   The MD5 checksum plugin <tt>MD5ChangeDetector.java</tt>
   queries the database and remembers the MD5 checksum of the ResultSet. On next query the MD5
   is compared to the last one and if it has changed a message is published.
   This detection works only satisfying if the table does not contain too much data.<br />
   The timestamp based plugin <tt>TimestampChangeDetector.java</tt> accesses on each
   poll all newer database rows and publishes them. This is only possible if the
   database table contains a column (or compound columns) which contains for example a DATE or TIMESTAMP
   information or any other column which is known to change.<br />
   For more details consult the Javadoc description of the plugins.
   </li>

   <li><tt>I_DbPool</tt><quote>How to access the database?</quote><br />
   We provide a pooled database access plugin <tt>DbPool.java</tt> for performant DB access,
   it is based on xmlBlasters db-pool implementation. Again, you can
   replace this by your own existing implementation if needed.
   </li>

   <li><tt>I_Info</tt><quote>How to pass the configuration to DbWatcher?</quote><br />
   We provide a simple plugin based on <tt>java.utils.prefs</tt>, with this you
   can run DbWatcher as a standalone program, totally independent from xmlBlaster.<br />
   Further we provide a wrapper to the xmlBlaster configuration framework <tt>Global</tt>
   which allows us to run DbWatcher as a native plugin of xmlBlaster.
   </li>
  </ol>

  <p>
  The javadoc of each interface contains enough information to assist you
  writing your own customized plugin.
  </p>


  <h2>Database change detection</h2>
  <p>The most difficult point is how to get a change event when a foreign application changes
  data on the database.</p>
  <p>There are following ways to detect DB changes, in future we could add such additional
  detection plugins:</p>
<ol>
<li>
   <h3>Changes are delivered by a MOM</h3>
   No DbWatcher is needed: This is the proper approach.
   As legacy systems have various channels which manipulate
   the DB directly it is no solution for older systems.
</li>

<li>
   <h3>Modify/Creation timestamp column</h3>
   A trigger adds the timestamp to each table<br />
   -> This changes the DB schema<br />
   This is supported by our <tt>TimestampChangeDetector.java</tt> plugin.
</li>

<li>
   <h3>Sequence of primary key</h3>
   Tables which contain a growing sequence of keys may
   use this to detect inserts<br />
   -> Failes for 'update'
</li>

<li>
   <h3>Using a LogMiner</h3>
   -> Is database specific
</li>

<li>
   <h3>Audit tables (with trigger)</h3>
   Need to start database in audit mode
   -> How does it work in a portable way?
</li>

<li>
   <h3>Having a trigger for each table</h3>
   The trigger notifies a stored procedure which sends a notify message over xmlBlaster
   to DbWatcher to poll again.<br />
   -> This needs to change the DB
   -> What if foreign database?
   http://www.oracle.com/technology/oramag/oracle/03-jan/o13java.html
   <br />
   This is supported by our <tt>XmlBlasterPublisher.java</tt> plugin.
</li>

<li>
   <h3>Flashback queries</h3>
   -> http://www.oracle.com/technology/products/oracle9i/daily/apr18.html
</li>

<li>
   <h3>Use ora_rowscan (since Oracle 10g, similar for MS-SQLServer)</h3>
   Example for Oracle (http://www.remote-dba.net/10g_26.htm):<br />
   <tt>select scn_to_timestamp(ora_rowscn) FROM A where ora_rowscn IS NOT null;</tt><br />
   Allows to retrieve the rowchange timestamps, but is of limited use
   as it is a timestamp of the table and not for each row. Like this
   we know the table has changed but we don't know which row.<br />
   SQLServer uses the column type <tt>rowVersion</tt>.<br />
   -> Missing for Oracle 9 and other DBs, Oracle 10g and MSQLServer support it.
</li>
   
<li>
   <h3>Using a customized select with MD5</h3>
   Query everything and remember the last state with MD5.
   On change send the complete data again.
   This is supported by our <tt>MD5ChangeDetector.java</tt> plugin.
</li>
</ol>
   <h2>Configuration hint</h2>
   <p>To configure your own poller you can take the simple
   standalone example client <tt>xmlBlaster/src/java/org/xmlBlaster/contrib/dbwatcher/Example.java</tt>
   adjust your query configuration and start it interactively. The <tt>testlog.properties</tt>
   in the same directory switches on fine logging and you can manually see what happens.
   </p>

   <h2>Logging hint</h2>
   <p>DbWatcher is using the JDK 1.4 logging framework. When running natively
   as xmlBlaster plugin this logging output is redirected to xmlBlaster utils logging.
   To switch on detailed logging, add those lines to <tt>xmlBlaster.properties</tt>:</p>
   <pre>
trace[org.xmlBlaster.contrib.dbwatcher.convert.ResultSetToXmlConverter] true
trace[org.xmlBlaster.contrib.db.DbPool] true
trace[org.xmlBlaster.contrib.dbwatcher.detector.MD5ChangeDetector] true
trace[org.xmlBlaster.contrib.dbwatcher.detector.AlertScheduler] true
trace[org.xmlBlaster.contrib.dbwatcher.detector.TimestampChangeDetector] true
trace[org.xmlBlaster.contrib.dbwatcher.plugin.DbWatcherPlugin] true
trace[org.xmlBlaster.contrib.dbwatcher.mom.XmlBlasterPublisher] true
trace[org.xmlBlaster.contrib.dbwatcher.DbWatcher] true
   </pre>


   <h2 id="Limitations">Limitations</h2>
   <p>Every change detector has pro and cons and limitations, the following table
   gives an overview for the currently supplied detector plugins.</p>
   <table border="1">
     <tr>
       <th>DB statement</th>
       <th>MD5ChangeDetector</th>
       <th>TimestampChangeDetector</th>
     </tr>
     <tr>
       <td>CREATE</td>
       <td>OK</td>
       <td>OK</td>
     </tr>
     <tr>
       <td>INSERT</td>
       <td>OK</td>
       <td>OK (reported as UPDATE)</td>
     </tr>
     <tr>
       <td>UPDATE</td>
       <td>OK</td>
       <td>OK</td>
     </tr>
     <tr>
       <td>DELETE</td>
       <td>OK (see <tt>mom.eraseOnDelete</tt> setting)</td>
       <td>Not detected</td>
     </tr>
     <tr>
       <td>DROP</td>
       <td>OK (see <tt>mom.eraseOnDrop</tt> setting)</td>
       <td>OK (see <tt>mom.eraseOnDrop</tt> setting)</td>
     </tr>
     <tr>
       <td>Comment</td>
       <td>Not suitable for huge tables as the complete table is scanned.
           Works with any table.
       </td>
       <td>Suitable for tables which huge amount of rows, does not detect row deletes.
           Needs a timestamp column (or an ascending counter) in the observed table.
       </td>
     </tr>
   </table>
   </description>


   <example lang="any" type="HTML">
   <h2 id="exampleTimestamp">Timestamp based polling example</h2>

   <p>
      Lets create a database table <tt>TEST_POLL</tt> which contains
      a <tt>TIMESTAMP</tt> column <tt>TS</tt> (tested on Oracle):
   </p>
   <pre>
set autocommit on;

CREATE TABLE TEST_POLL (COLOR VARCHAR(10), TS TIMESTAMP, CAR VARCHAR(10));

INSERT INTO TEST_POLL VALUES ('green', CURRENT_TIMESTAMP, 'Fiat');
INSERT INTO TEST_POLL VALUES ('red', CURRENT_TIMESTAMP, 'Lada');
INSERT INTO TEST_POLL VALUES ('blue', CURRENT_TIMESTAMP, 'BMW');
INSERT INTO TEST_POLL VALUES ('pink', CURRENT_TIMESTAMP, 'Fiat');
INSERT INTO TEST_POLL VALUES ('white', CURRENT_TIMESTAMP, 'Fiat');

SELECT * FROM TEST_POLL ORDER BY CAR;
   </pre>

   <p>
   Now we configure a xmlBlaster native DbWatcher plugin in <tt>xmlBlasterPlugins.xml</tt>
   </p>

  <pre>
<font color="gray">&lt;plugin id='DbWatcherPlugin.testPoll' 
           className='org.xmlBlaster.contrib.dbwatcher.plugin.DbWatcherPlugin'>
   <font color="blue">&lt;attribute id='jdbc.drivers'>oracle.jdbc.driver.OracleDriver&lt;/attribute>
   &lt;attribute id='db.url'>jdbc:oracle:thin:@localhost:1521:orcl&lt;/attribute>
   &lt;attribute id='db.user'>system&lt;/attribute>
   &lt;attribute id='db.password'>secret&lt;/attribute></font>
   <font color="green">&lt;attribute id='mom.loginName'>DbWatcherPlugin.testPoll/1&lt;/attribute>
   &lt;attribute id='mom.topicName'>db.test_poll.event.${groupColValue}&lt;/attribute></font>
   <font color="orange">&lt;attribute id='alertScheduler.pollInterval'>10000&lt;/attribute></font>
   <font color="red">&lt;attribute id='changeDetector.class'>
      org.xmlBlaster.contrib.dbwatcher.detector.TimestampChangeDetector
   &lt;/attribute>
   &lt;attribute id='changeDetector.groupColName'><b>CAR</b>&lt;/attribute>
   &lt;attribute id='changeDetector.detectStatement'>
      SELECT <b>MAX(TO_CHAR(TS, 'YYYY-MM-DD HH24:MI:SSXFF'))</b> from TEST_POLL
   &lt;/attribute>
   &lt;attribute id='db.queryMeatStatement'>
      SELECT * FROM TEST_POLL WHERE <b>TO_CHAR(TS, 'YYYY-MM-DD HH24:MI:SSXFF') > '${oldTimestamp}'</b> <b>ORDER BY CAR</b>
   &lt;/attribute></font>
   &lt;action do='LOAD' onStartupRunlevel='9' sequence='6'
              onFail='resource.configuration.pluginFailed'/>
   &lt;action do='STOP' onShutdownRunlevel='6' sequence='5'/>
&lt;/plugin></font>
  </pre>
  <p>
  <ul>
    <li>We register the plugin with the <tt>plugin</tt> tag and give it a unique name <font color="gray">(gray)</font>.</li>
    <li>We need to setup the database access <font color="blue">(blue)</font>.</li>
    <li>We need to setup the xmlBlaster access <font color="green">(green)</font>.</li>
    <li>The plugin is configured to poll every 10 seconds with <tt>alertScheduler.pollInterval=10000</tt> <font color="orange">(orange)</font>.</li>
    <li>In this case we want a separate topic for each CAR entry (<tt>changeDetector.groupColName=CAR</tt>),
        we detect a change on table <tt>TEST_POLL</tt> with the query
        <tt>SELECT MAX(TO_CHAR(TS, 'YYYY-MM-DD HH24:MI:SSXFF')) from TEST_POLL</tt>
        and all changed rows since the last query are processed with
        <tt>SELECT * FROM TEST_POLL WHERE TO_CHAR(TS, 'YYYY-MM-DD HH24:MI:SSXFF') > '${oldTimestamp}' ORDER BY CAR</tt>
        and published to topics depending on the current car, for example <tt>db.test_poll.event.Fiat</tt> <font color="red">(red)</font>.</li>
    <li>NOTE: The <tt>ORDER BY CAR</tt> is a must to get events for each car change.</li>
  </ul>
  </p>

  <p>To see what messages are published start the server and a client<br />
  <tt>java org.xmlBlaster.Main -trace[org.xmlBlaster.contrib.dbwatcher.plugin.DbWatcherPlugin] true</tt><br />
  <tt>java javaclients.HelloWorldSubscribe -xpath //key -maxContentLength 1000</tt><br />
  and press one time enter to subscribe to all messages.</p>

  <p>These are the three messages you receive on startup:</p>
   <pre>
---------------------------------------
&lt;key oid='db.test_poll.event.BMW'/>

&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
 &lt;desc>
  &lt;command>UPDATE&lt;/command>
  &lt;ident>BMW&lt;/ident>
  &lt;colname type='VARCHAR2' precision='10'>COLOR&lt;/colname>
  &lt;colname type='TIMESTAMP' scale='1'>TS&lt;/colname>
  &lt;colname type='VARCHAR2' precision='10'>CAR&lt;/colname>
 &lt;/desc>
 &lt;row num='0'>
  &lt;col name='COLOR'>blue&lt;/col>
  &lt;col name='TS'>2005-1-11.15.15. 30. 566126000&lt;/col>
  &lt;col name='CAR'>BMW&lt;/col>
 &lt;/row>
&lt;/sql>

---------------------------------------
&lt;key oid='db.test_poll.event.Fiat'/>

&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
 &lt;desc>
  &lt;command>UPDATE&lt;/command>
  &lt;ident>Fiat&lt;/ident>
  &lt;colname type='VARCHAR2' precision='10'>COLOR&lt;/colname>
  &lt;colname type='TIMESTAMP' scale='1'>TS&lt;/colname>
  &lt;colname type='VARCHAR2' precision='10'>CAR&lt;/colname>
 &lt;/desc>
 &lt;row num='0'>
  &lt;col name='COLOR'>green&lt;/col>
  &lt;col name='TS'>2005-1-11.11.53. 34. 263515000&lt;/col>
  &lt;col name='CAR'>Fiat&lt;/col>
 &lt;/row>
 &lt;row num='1'>
  &lt;col name='COLOR'>pink&lt;/col>
  &lt;col name='TS'>2005-1-11.11.53. 34. 447328000&lt;/col>
  &lt;col name='CAR'>Fiat&lt;/col>
 &lt;/row>
 &lt;row num='2'>
  &lt;col name='COLOR'>white&lt;/col>
  &lt;col name='TS'>2005-1-11.11.53. 34. 456153000&lt;/col>
  &lt;col name='CAR'>Fiat&lt;/col>
 &lt;/row>
&lt;/sql>

---------------------------------------
&lt;key oid='db.test_poll.event.Lada'/>

&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
 &lt;desc>
  &lt;command>UPDATE&lt;/command>
  &lt;ident>Lada&lt;/ident>
  &lt;colname type='VARCHAR2' precision='10'>COLOR&lt;/colname>
  &lt;colname type='TIMESTAMP' scale='1'>TS&lt;/colname>
  &lt;colname type='VARCHAR2' precision='10'>CAR&lt;/colname>
 &lt;/desc>
 &lt;row num='0'>
  &lt;col name='COLOR'>red&lt;/col>
  &lt;col name='TS'>2005-1-11.11.53. 34. 425024000&lt;/col>
  &lt;col name='CAR'>Lada&lt;/col>
 &lt;/row>
&lt;/sql>
   </pre>

   <p>Now to verify the detection, we update one table row</p>
   <pre>
set autocommit on;
UPDATE TEST_POLL SET COLOR='yellow', TS=CURRENT_TIMESTAMP WHERE CAR='BMW';
   </pre>

   <p>and your subscriber should receive this message</p>
   <pre>
&lt;key oid='db.change.BMW'/>

&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
 &lt;desc>
  &lt;command>UPDATE&lt;/command>
  &lt;ident>BMW&lt;/ident>
  &lt;colname type='VARCHAR2' precision='10'>COLOR&lt;/colname>
  &lt;colname type='TIMESTAMP' scale='1'>TS&lt;/colname>
  &lt;colname type='VARCHAR2' precision='10'>CAR&lt;/colname>
 &lt;/desc>
 &lt;row num='0'>
  &lt;col name='COLOR'>yellow&lt;/col>
  &lt;col name='TS'>2005-1-11.15.52. 1. 204668000&lt;/col>
  &lt;col name='CAR'>BMW&lt;/col>
 &lt;/row>
&lt;/sql>
   </pre>

   </example>

   <example lang="any" type="HTML">
   <h2 id="exampleMD5">MD5 based polling example</h2>

   <p>The same table used in the previous example can be polled with MD5 comparison as well:
   </p>
  <pre>
&lt;plugin id='DbWatcherPlugin.testPoll_MD5' 
           className='org.xmlBlaster.contrib.dbwatcher.plugin.DbWatcherPlugin'>
   &lt;attribute id='jdbc.drivers'>oracle.jdbc.driver.OracleDriver&lt;/attribute>
   &lt;attribute id='db.url'>jdbc:oracle:thin:@localhost:1521:orcl&lt;/attribute>
   &lt;attribute id='db.user'>system&lt;/attribute>
   &lt;attribute id='db.password'>secret&lt;/attribute>
   &lt;attribute id='mom.loginName'>DbWatcherPlugin.testPoll/2&lt;/attribute>
   &lt;attribute id='mom.topicName'>db.test_poll.event.${groupColValue}&lt;/attribute>
   &lt;attribute id='alertScheduler.pollInterval'>2000&lt;/attribute>
   <font color="red">&lt;attribute id='changeDetector.class'>
      org.xmlBlaster.contrib.dbwatcher.detector.MD5ChangeDetector
   &lt;/attribute>
   &lt;attribute id='changeDetector.groupColName'><b>CAR</b>&lt;/attribute>
   &lt;attribute id='changeDetector.detectStatement'>
      SELECT color, car from TEST_POLL order by <b>CAR</b>
   &lt;/attribute>
      &lt;attribute id='db.queryMeatStatement'>
      SELECT * FROM TEST_POLL WHERE <b>CAR</b> = '${groupColValue}'
   &lt;/attribute></font>
   &lt;action do='LOAD' onStartupRunlevel='9' sequence='6'
              onFail='resource.configuration.pluginFailed'/>
   &lt;action do='STOP' onShutdownRunlevel='6' sequence='5'/>
&lt;/plugin>
  </pre>


   <p>The only difference to the timestamp based example is that we can detect
   DELETE statements:
   </p>
   <pre>
set autocommit on;
DELETE FROM TEST_POLL WHERE CAR='BMW';
   </pre>

   <p>and your subscriber should receive this message</p>
   <pre>
&lt;key oid='db.test_poll.event.BMW'/>

&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
 &lt;desc>
  &lt;command>DELETE&lt;/command>
  &lt;ident>BMW&lt;/ident>
 &lt;/desc>
&lt;/sql>
 &lt;/content>
   </pre>

   </example>

   <example lang="any" type="HTML">
   <h2 id="exampleTriggerMsg">Trigger the polling with xmlBlaster messages</h2>

   <p>The alert scheduler plugin typically polls for changes on the database.
   There is also support to poll the database after getting a kick by a 
   xmlBlaster message send by some client. Here is an example setup:
   </p>
  <pre>
&lt;plugin id='DbWatcherPlugin.testPoll-MsgTriggered' 
           className='org.xmlBlaster.contrib.dbwatcher.plugin.DbWatcherPlugin'>
   &lt;attribute id='jdbc.drivers'>oracle.jdbc.driver.OracleDriver&lt;/attribute>
   &lt;attribute id='db.url'>jdbc:oracle:thin:@localhost:1521:orcl&lt;/attribute>
   &lt;attribute id='db.user'>system&lt;/attribute>
   &lt;attribute id='db.password'>secret&lt;/attribute>
   &lt;attribute id='db.queryMeatStatement'>
      SELECT * FROM TEST_POLL WHERE TO_CHAR(TS, 'YYYY-MM-DD HH24:MI:SSXFF') > '${oldTimestamp}' ORDER BY CAR
   &lt;/attribute>
   &lt;attribute id='mom.loginName'>DbWatcherPlugin.testPoll/1&lt;/attribute>
   &lt;attribute id='mom.topicName'>db.test_poll.event.${groupColValue}&lt;/attribute>
   <font color="orange"><b>&lt;attribute id='alertProducer.class'>org.xmlBlaster.contrib.dbwatcher.mom.XmlBlasterPublisher&lt;/attribute>
   &lt;attribute id='mom.alertSubscribeKey'>&lt;key oid='checkDb'/>&lt;/attribute>
   &lt;attribute id='mom.alertSubscribeQos'>&lt;qos/>&lt;/attribute></b></font>
   &lt;attribute id='changeDetector.class'>
      org.xmlBlaster.contrib.dbwatcher.detector.TimestampChangeDetector
   &lt;/attribute>
   &lt;attribute id='changeDetector.groupColName'>CAR&lt;/attribute>
   &lt;attribute id='changeDetector.detectStatement'>
      SELECT MAX(TO_CHAR(TS, 'YYYY-MM-DD HH24:MI:SSXFF')) from TEST_POLL
   &lt;/attribute>
   &lt;action do='LOAD' onStartupRunlevel='9' sequence='6'
              onFail='resource.configuration.pluginFailed'/>
   &lt;action do='STOP' onShutdownRunlevel='6' sequence='5'/>
&lt;/plugin>
   </pre>

   <p>You can now test a poll with a command line publish, first start a subscriber
   so we can see what happens:</p>
   <tt>java javaclients.HelloWorldSubscribe -xpath //key -session.name subscriber/1 -maxContentLength 1000</tt>
   <p>and then publish an alert message which triggers a database poll:</p>
   <tt>java javaclients.HelloWorldPublish -oid checkDb -numPublish 10 -erase false</tt>

   <p>An additional feature of the <tt>TimestampChangeDetector</tt> plugin
   allows you to send the <tt>oldTimestamp</tt> and
   the change detector will send all messages newer than your supplied timestamp,
   for example:</p>
   <tt>java javaclients.HelloWorldPublish -oid checkDb -clientProperty[oldTimestamp] "2005-02-01 11:59:24.639575" -erase false</tt>
   <p>You can also <i>misuse</i> this feature to send an <tt>oldTimestamp</tt>
   far in the future and like this set the DbWatcher on standby.</p>

   </example>



   <example lang="any" type="HTML">

   <h2>Example for table creation change event message</h2>
<pre>
&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
 &lt;desc>
  &lt;command>CREATE&lt;/command>
  &lt;colname type='NUMBER' precision='10' scale='3'>COLKEY&lt;/colname>
  &lt;colname type='VARCHAR2' precision='20'>COL1&lt;/colname>
  &lt;colname type='NUMBER' precision='12'>COL2&lt;/colname>
  &lt;colname type='VARCHAR2' precision='10'>ICAO_ID&lt;/colname>
 &lt;/desc>
&lt;/sql>
</pre>


   <h2>Example for change event message</h2>
<pre>
&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
 &lt;desc>
  &lt;command>INSERT&lt;/command>
  &lt;ident>EDDI&lt;/ident>
  &lt;colname type='DATE' isNullable='0'>DATUM&lt;/colname>
  &lt;colname type='NUMBER' precision='11' scale='0'
              signed='false'>CPU&lt;/colname>
  &lt;colname type='VARCHAR2' precision='20' isReadOnly='true'>COL1&lt;/colname>
  &lt;colname table='OMZ' schema='AA' catalog='CAT' type='VARCHAR2'
              precision='10'>ICAO_ID&lt;/colname>
 &lt;/desc>
 &lt;row num='0'>
  &lt;col name='DATUM'>2005-01-05 15:52:06.0&lt;/col>
  &lt;col name='CPU'>238333&lt;/col>
  &lt;col name='COL1'>&lt;![CDATA[&lt;Bla]]&gt;&lt;/col>
  &lt;col name='ICAO_ID'>EDDI&lt;/col>
  &lt;attr name='LR'>SRANIL&lt;/attr>
  &lt;attr name='SUBNET_ID'>TCP&lt;/attr>
 &lt;/row>
 &lt;row num='1'>
  &lt;col name='DATUM'>2005-01-05 15:52:07.0&lt;/col>
  &lt;col name='CPU'>238340&lt;/col>
  &lt;col name='COL1' encoding='base64'>QmxdXT5CbA==&lt;/col>
  &lt;col name='ICAO_ID'>EDDI&lt;/col>
 &lt;/row>
 &lt;row num='2'>
  &lt;col name='DATUM'>2005-01-05 15:52:08.0&lt;/col>
  &lt;col name='CPU'>238343&lt;/col>
  &lt;col name='COL1'>BOO&lt;/col>
  &lt;col name='ICAO_ID'>EDDI&lt;/col>
  &lt;attr name='SUBNET_ID'>X25&lt;/attr>
 &lt;/row>
&lt;/sql>
</pre>
  <p>Data which would break the xml of being well-formed are enclosed with a CDATA section,
     data which contains a CDATA end-token is delivered base64 encoded.
  </p>

   <h2>Example for a deleted entry message</h2>
   <p>The topic name specifies the entry, for example <tt>'db.change.event.EDDI'</tt>, the content
   contains a <tt>DELETE</tt> command:
   </p>
<pre>
&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
   &lt;desc>
   &lt;command>DELETE&lt;/command>
   &lt;ident>EDDI&lt;/ident>
   &lt;/desc>
&lt;/sql>
</pre>
   <p>Use the <tt>mom.eraseOnDelete=true</tt> configuration to delete the topic on
   a table row DELETE event.</p>

   <h2>Example for a drop entry message</h2>
<pre>
&lt;?xml version='1.0' encoding='UTF-8' ?>
&lt;sql>
 &lt;desc>
  &lt;command>DROP&lt;/command>
  &lt;ident>EDDI&lt;/ident>
 &lt;/desc>
&lt;/sql>
</pre>
   <p>Use the <tt>mom.eraseOnDrop=true</tt> configuration to delete the topic on
   a table DROP event.</p>

   </example>

   <example lang="any" type="HTML">

   <h2>Example for Microsoft SQLServer with rowversion column</h2>
<pre>
&lt;plugin id='DbWatcherPlugin.testTS' 
         className='org.xmlBlaster.contrib.dbwatcher.plugin.DbWatcherPlugin'>
   &lt;attribute id='jdbc.drivers'>com.microsoft.jdbc.sqlserver.SQLServerDriver&lt;/attribute>
   &lt;attribute id='db.url'>
      jdbc:microsoft:sqlserver://localhost:1433;SelectMethod=cursor;DatabaseName=mydb
   &lt;/attribute>
   &lt;attribute id='db.user'>sa&lt;/attribute>
   &lt;attribute id='db.password'>secret&lt;/attribute>
   &lt;attribute id='mom.loginName'>DbWatcherPlugin.testPoll/1&lt;/attribute>
   &lt;attribute id='mom.topicName'>db.test_poll.event&lt;/attribute>

   &lt;attribute id='alertScheduler.pollInterval'>500&lt;/attribute>
   &lt;attribute id='changeDetector.class'>
      org.xmlBlaster.contrib.dbwatcher.detector.TimestampChangeDetector
   &lt;/attribute>

   &lt;!-- timestamp variable, we want to get each row seperately -->
   &lt;attribute id='changeDetector.groupColName'>polterTS&lt;/attribute>

   &lt;!-- check if there was any change -->
   &lt;attribute id='changeDetector.detectStatement'>
      SELECT MAX(CAST(polterTS as datetime)) from polter
   &lt;/attribute>

   &lt;!-- each result row will be one explicit publish -->
   &lt;attribute id='db.queryMeatStatement'>
      SELECT * FROM  polter WHERE CAST(polterTS as datetime) > '${oldTimestamp}' ORDER BY polterTS
   &lt;/attribute>
   &lt;attribute id='mom.eraseOnDelete'>true&lt;/attribute>
   &lt;attribute id='mom.eraseOnDrop'>true&lt;/attribute>
   &lt;action do='LOAD' onStartupRunlevel='6' sequence='6'
               onFail='resource.configuration.pluginFailed'/>
   &lt;action do='STOP' onShutdownRunlevel='5' sequence='6'/>
&lt;/plugin>
</pre>
   <p>
   The polterTS column is of type <tt>rowVersion</tt>.
   You can add such a column with this command:
   </p>
   <pre>alter table [xxx].[polter] add polterTS rowversion</pre>
   </example>

   <configuration where="server">
      <p>
         The plugin is configured in the <tt>xmlBlasterPlugins.xml</tt> configuration file.
         If you run DbWatcher outside of xmlBlaster the <tt>I_Info</tt> interface
         must return those settings.
      </p>

    <table border="1">
       <tr>
         <th>Id (name)</th>
         <th>Type</th>
         <th>Manda
         tory</th>
         <th>Default value</th>
         <th>Comment</th>
       </tr>

       <tr>
         <td>dbPool.class</td>
         <td>String</td>
         <td>yes</td>
         <td>org.xmlBlaster.contrib.db.DbPool</td>
         <td>
         Configures your implementation of interface <tt>I_DbPool</tt>.
         </td>
       </tr>
       <tr>
         <td>converter.class</td>
         <td>String</td>
         <td>yes</td>
         <td>org.xmlBlaster.contrib.dbwatcher. convert.ResultSetToXmlConverter</td>
         <td>
         Configures your implementation of interface <tt>I_DataConverter</tt>.
         </td>
       </tr>
       <tr>
         <td>mom.class</td>
         <td>String</td>
         <td>yes</td>
         <td>org.xmlBlaster.contrib.dbwatcher. mom.XmlBlasterPublisher</td>
         <td>
         Configures your implementation of interface <tt>I_ChangePublisher</tt>
         </td>
       </tr>
       <tr>
         <td>changeDetector.class</td>
         <td>String</td>
         <td>yes</td>
         <td>org.xmlBlaster.contrib.dbwatcher. detector.MD5ChangeDetector</td>
         <td>
         Configures your implementation of interface <tt>I_ChangeDetector</tt>
         </td>
       </tr>
       <tr>
         <td>alertProducer.class</td>
         <td>String</td>
         <td>yes</td>
         <td>org.xmlBlaster.contrib.dbwatcher. detector.AlertScheduler</td>
         <td>
         Configures your implementation of interface <tt>I_AlertProducer</tt>
         Here you can configure multiple classes with a comma separated list.
         Each of them can trigger an new check in parallel, for example
         <tt>alertProducer.class= org.xmlBlaster.contrib.dbwatcher. mom.XmlBlasterPublisher, org.xmlBlaster.contrib.dbwatcher. detector.AlertSchedulery</tt> will check regularly via
         the AlertScheduler and on message via XmlBlasterPublisher.
         </td>
       </tr>
       <tr>
         <td>transformer.class</td>
         <td>String</td>
         <td>no</td>
         <td>yes</td>
         <td>
         If not empty or null the specified plugin implementing
         <tt>I_AttributeTransformer</tt> is loaded. 
         This plugin is called once for each xml dump and adds <tt>&lt;attr></tt> tags as returned by the plugin.
         This feature is available when using <tt>ResultSetToXmlConverter</tt>.
         </td>
       </tr>

       <tr>
         <td>jdbc.drivers</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>
         For example <tt>oracle.jdbc.driver.OracleDriver</tt>,
         the database specific driver jar file which contains the above
         class must be in the class path.
         </td>
       </tr>
       <tr>
         <td>db.url</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>
         For example <tt>jdbc:oracle:thin:@localhost:1521:orcl</tt>.
         </td>
       </tr>
       <tr>
         <td>db.user</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>
         The database user login name.
         </td>
       </tr>
       <tr>
         <td>db.password</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>
         The database password.
         </td>
       </tr>

       <tr>
         <td>mom.connectQos</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>If you need to specify more complex 
         <a href="interface.connect.html">connection behavior</a> you can do it here. Note however that
         this is a plugin which per default uses the <a href="protocol.local.html">local protocol</a>.
         </td>
       </tr>
       <tr>
         <td>mom.loginName</td>
         <td>String</td>
         <td>yes</td>
         <td>'_' + id of plugin</td>
         <td>If the id of the plugin is <i>DbWatcher1</i>, then the default <i>loginName</i>
         is <i>_DbWatcher1</i>. If you specify a <i>connectQos</i>, then this attribute is ignored.
         </td>
       </tr>
       <tr>
         <td>mom.password</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>This is the password to be used to authenticate the <i>loginName</i>.
         If you specify a <i>connectQos</i>, then this attribute is ignored.
         </td>
       </tr>
       <tr>
         <td>mom.topicName</td>
         <td>String</td>
         <td>(yes)</td>
         <td>db.change.event.${groupColValue}</td>
         <td>Mandatory unless <i>publishKey</i> defined. If both are specified this attribute is
         ignored and a warning is logged. This is the name of the topic on which to publish (the oid).<br />
         If you have specified a <tt>groupColName</tt> a message for every change of this column
         in the result set triggers a message, the ${} token is replaced by the current columns value.
         </td>
       </tr>
       <tr>
         <td>mom.publishKey</td>
         <td>String</td>
         <td>(no)</td>
         <td>null</td>
         <td>Optional unless <tt>topicName</tt> has not been specified in which case it is mandatory.
         If you need to specify a more complex <a href="interface.publish.html">key</a> for the publishing 
         (for example to make it searcheable)
         of the messages you can specify it here. Note that you can only specify one single key which will
         be used for all messages published by this plugin. If you need to differentiate you can use
         more plugins.
         </td>
       </tr>
       <tr>
         <td>mom.publishQos</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>
         If you need to specify a more complex <a href="interface.publish.html">qos</a> for the publishing 
         you can specify it here. Note that you can only specify one single qos which will
         be used for all messages published by this plugin. If you need to differentiate you can use
         more plugins.
         </td>
       </tr>
       <tr>
         <td>mom.eraseOnDrop</td>
         <td>String</td>
         <td>no</td>
         <td>false</td>
         <td>When a table drop is detected, shall we erase the topic in xmlBlaster or shall we just send
         a message containing the <tt>DROP</tt> command?
         </td>
       </tr>
       <tr>
         <td>mom.eraseOnDelete</td>
         <td>String</td>
         <td>no</td>
         <td>false</td>
         <td>When a table row delete is detected, shall we erase the topic in xmlBlaster or shall we just send
         a message containing the <tt>DELETE</tt> command?
         </td>
       </tr>
       <tr>
         <td>mom.alertSubscribeKey</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>
         The <tt>XmlBlasterPubliser</tt> plugin implements <tt>I_AlertProducer.java</tt>
         as well and can be configured to listen on a topic.
         When a message arrives there we trigger a new database poll.
         </td>
       </tr>
       <tr>
         <td>mom.alertSubscribeQos</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>
         QoS for the subscription.
         </td>
       </tr>

       <tr>
         <td>alertScheduler.pollInterval</td>
         <td>long</td>
         <td>no</td>
         <td>2000</td>
         <td>The time in milliseconds the <tt>AlertScheduler</tt> plugin sleeps between each poll sweep.
         </td>
       </tr>



       <tr>
         <td>db.queryMeatStatement</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>
         If given this statement is used to gather the information which is placed into the message.<br />
         The statement needs to be ordered by the configured <tt>changeDetector.groupColName</tt>
         to be able to send a message on each columns change. If <tt>changeDetector.groupColName</tt>
         is null, any statement is possible.
         </td>
       </tr>
       <tr>
         <td>changeDetector. groupColName</td>
         <td>String</td>
         <td>no</td>
         <td>null</td>
         <td>
         This is null or a valid column name of the database table observed.
         If configured the query statemts should be order by the same table column
         so that on each change in the result set a message is sent.
         </td>
       </tr>
       <tr>
         <td>changeDetector. detectStatement</td>
         <td>String</td>
         <td>yes</td>
         <td>null</td>
         <td>
         Depending on the <tt>changeDetector.class</tt> configured
         you have to provide a useful SQL statement which detects changes
         on the observed database. For the MD5 checksum plugin it should
         contain all columns which are observed. For the Timestamp plugin
         you need to query the max timestamp of the observed table.
         </td>
       </tr>
       <tr>
         <td>changeDetector. timestampColNum</td>
         <td>String</td>
         <td>no</td>
         <td>1</td>
         <td>
         For <tt>TimestampChangeDetector</tt> plugin only:
         The JDBC index (starts with 1) of the column containing the max(timestamp) column
         of the <tt>changeDetector.detectStatement</tt>. This usually is always 1 and
         you don't need to configure anything here.
         </td>
       </tr>
       <tr>
         <td>converter.rootName</td>
         <td>String</td>
         <td>no</td>
         <td>sql</td>
         <td>
         For <tt>ResultSetToXmlConverter</tt> plugin only:
         Name of the XML root tag.
         </td>
       </tr>
       <tr>
         <td>converter.addMeta</td>
         <td>String</td>
         <td>no</td>
         <td>true</td>
         <td>
         For <tt>ResultSetToXmlConverter</tt> plugin only:
         If <tt>false</tt> suppress meta information, the CREATE statement however will
         always transport the meta tags.
         </td>
       </tr>
       <tr>
         <td>charSet</td>
         <td>String</td>
         <td>no</td>
         <td>UTF-8</td>
         <td>
         The charset used.
         </td>
       </tr>

       <tr>
         <td>xmlBlaster/jdk14loggingCapture</td>
         <td>boolean</td>
         <td>no</td>
         <td>true</td>
         <td>
         Redirects JDK 1.4 logging output of this plugin into xmlBlasters jutils logging framework.
         </td>
       </tr>
     </table>   

  <p>
  The plugin is configured in the <tt>xmlBlasterPlugins.xml</tt> configuration file. Here an example where
  most properties are used:
  </p>
<pre>
<![CDATA[
  <xmlBlaster>
    ...

  <plugin id='DbWatcherPlugin.MD5'
          className='org.xmlBlaster.contrib.dbwatcher.plugin.DbWatcherPlugin'>
     <attribute id='jdbc.drivers'>oracle.jdbc.driver.OracleDriver</attribute>
     <attribute id='db.url'>jdbc:oracle:thin:@localhost:1521:orcl</attribute>
     <attribute id='db.user'>system</attribute>
     <attribute id='db.password'>secret</attribute>
     <attribute id='db.queryMeatStatement'></attribute>
     <attribute id='mom.topicName'>db.change.event.${groupColValue}</attribute>
     <attribute id='mom.loginName'>dbWatcher/1</attribute>
     <attribute id='mom.password'>secret</attribute>
     <attribute id='mom.alertSubscribeKey'><key oid=''/></attribute>
     <attribute id='mom.alertSubscribeQos'><qos/></attribute>
     <attribute id='changeDetector.class'>
        org.xmlBlaster.contrib.dbwatcher.detector.MD5ChangeDetector
     </attribute>
     <attribute id='alertScheduler.pollInterval'>5000</attribute>
     <attribute id='changeDetector.groupColName'>ICAO_ID</attribute>
     <attribute id='changeDetector.detectStatement'>
        SELECT col1, col2, ICAO_ID FROM TEST_POLL ORDER BY ICAO_ID
     </attribute>
     <attribute id='converter.class'>
        org.xmlBlaster.contrib.dbwatcher.convert.ResultSetToXmlConverter
     </attribute>
     <attribute id='transformer.class'></attribute>
     <action do='LOAD' onStartupRunlevel='9' sequence='6'
             onFail='resource.configuration.pluginFailed'/>
     <action do='STOP' onShutdownRunlevel='6' sequence='5'/>
   </plugin>
   ...

 </xmlBlaster>
]]>
</pre>
 <h3>Note:</h3>
 <p>
 Variables like <tt>${db.user}</tt> are replaced on startup when the plugin is loaded.
 You could add <tt>db.user=system</tt> into <tt>xmlBlaster.properties</tt> or on command line
 and <tt>${db.user}</tt> would be replaced to <tt>system</tt>.
 </p>
 <p>
 Now we face the problem that we need to set ${...} constructs which we want to pass through
 to the DbWatcher sub-plugins like <tt>MD5ChangeDetector</tt>. On plugin load they can't
 be resolved and an exception is thrown. To escape such variable please write <tt>$_{...}</tt>,
 for example <tt>$_{changeDetector.detectStatement}</tt>,
 and they will be passed through as is. The currently available sub-plugins themselves are capable to replace
 such constructs as well.<br />
 For most variables we have coded a work around in <tt>XmlBlasterPlugin.java</tt> but
 if you add own sub-plugins the work around does not detect it and you need to use <tt>$_</tt>
 (or in fact any other construct like <tt>$[..]</tt> if only your sub-plugin can handle it).
 </p>

 <h3>Needed class files</h3>
 <p>The complete DbWatcher code resides under
    <code>xmlBlaster/src/java/org/xmlBlaster/contrib</code>,
    after a <code>build all</code> it is compiled as well and
    available in <code>xmlBlaster.jar</code>.
 </p>
    <p>You can manually distribute it with</p>
    <pre>
    cd xmlBlaster/build.tmp/classes
    jar cvf dbwatcher.jar org/xmlBlaster/contrib
    </pre>

   </configuration>

   <todo type="HTML">
   <p>Port testsuite to run with HSQLDB and MS-SQLServer, currently the SQL statements from the testsuite
   are Oracle specific, currently you need a running Oracle, a running xmlBlaster and start the tests separately:</p>
   <p>
   <tt>java -Ddb.password=secret junit.swingui.TestRunner -noloading org.xmlBlaster.test.contrib.dbwatcher.TestResultSetToXmlConverter</tt>
   </p>
   <p>
   <tt>java -Ddb.password=secret junit.swingui.TestRunner -noloading org.xmlBlaster.test.contrib.dbwatcher.TestTimestamp</tt>
   </p>

   <p>Add other <tt>I_ChangeDetector</tt> plugins which scale better for tables with huge amount of entries.
   </p>
   </todo>

   <see type="API">org.xmlBlaster.contrib.dbwatcher.DbWatcher</see>
   <see type="API">org.xmlBlaster.contrib.dbwatcher.detector.MD5ChangeDetector</see>
   <see type="API">org.xmlBlaster.contrib.dbwatcher.detector.TimestampChangeDetector</see>
   <see type="REQ">engine.runlevel</see>
   <author>xmlblast@marcelruff.info</author>
   <hacker>xmlblast@marcelruff.info</hacker>
   <date>2005 01 02</date>
   <revision>$Revision: 1.7 $</revision>
   <testcase status="CLOSED">
      <name>-</name>
      <comment>-</comment>
      <test tool="SUITE">org.xmlBlaster.test.contrib.dbwatcher.TestTimestamp</test>
      <test tool="SUITE">org.xmlBlaster.test.contrib.dbwatcher.TestResultSetToXmlConverter</test>
   </testcase>
</requirement>

