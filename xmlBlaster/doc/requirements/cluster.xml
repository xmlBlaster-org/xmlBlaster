<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='cluster' type='NEW' prio='HIGH' status="INWORK">
   <topic>Multiple xmlBlaster instances can build a cluster following the master/slave paradigm</topic>
   <description>
      <p>
      We define a cluster as a configuration where more than one xmlBlaster
      server instance is running. The instances may run on the same host or
      distributed over the internet.
      </p>
      <p>
      All clustering abilities for xmlBlaster reduce to the simple master/slave approach.
      The cluster approach is easy to understand as we are not leaving the MoM paradigm
      to support clustering.
      </p>
      <p>
      An important part in clustering is the <i>discovery and lookup</i>.
      How to find other cluster nodes and access in depth
      node informations from them, and how to keep those informations up to date.
      This is addressed with the publish/subscribe idea as well.
      XmlBlaster nodes store their cluster informations in messages, so other nodes
      can subsrcribe to this data. If necessary one xmlBlaster is running as a 'naming service'
      holding the informations of all available xmlBlaster instances.
      </p>
      <p>
      In the following examples, we use the term <i>xmlBlaster server instance</i> and
      <i>xmlBlaster node</i> or just <i>node</i> interchangeable.
      </p>
      <center><p>
      <img src="cluster.gif" border="0" title="XmlBlaster cluster example" alt="Example for a typical xmlBlaster cluster" />
      </p></center>
      <p>
      In this example we have three xmlBlaster instances running, each of them has
      a unique cluster node ID, here the names <i>heron</i>, <i>golan</i> and <i>avalon</i>.
      </p>
      <p>
      Each of the nodes have an arbitrary number of clients attached. The clients
      can publish or subscribe to any message in the cluster, and may send PtP messages
      to any other client.
      </p>
      
      <hr />

      <h3>
      Clustering in our sense covers the following topics:
      </h3>
      <ol>
      <li><h4>Scalability:</h4><br />
      An xmlBlaster server instance allows to have any number of slave xmlBlaster server instances
      for specific message types. These slaves can have further slaves again.
      This allows distributing messages to an almost unlimited number of clients.
      Note that one xmlBlaster node can be a master for some messages and a slave for
      other message types simultaneously.
      <p>
      <img src="cluster.scalability.gif" border="0" title="XmlBlaster cluster example" alt="Example for a typical xmlBlaster cluster" />
      </p>
      <p>
      The example shows a tree like configuration of xmlBlaster nodes. In this way
      we can connect an almost unlimited number of clients. Every child leaf supplies
      a certain amount of slaves, which supplies other slaves which finally supply
      clients with message updates. The slaves are caching the messages and respond to
      request of their clients directly. The cache is always up to date as it is real time
      updated according to the publish/subscribe paradigm. 
      With every child level in the tree the latency increases
      for typically 5-40 milliseconds (intranet) for new published message updates.
      Note that the publisher does not need to be connected to the master node, the client in the
      down left edge of the picture is publishing as well.
      </p>
      </li>
      <li><h4>Availability (Failover):</h4><br />
      An xmlBlaster slave may adopt the master role for selective message types
      if the current xmlBlaster master fails.
      <p>
      <img src="cluster.availability.gif" border="0" title="XmlBlaster cluster example" alt="Example for a typical xmlBlaster cluster" />
      </p>
      </li>
      <li><h4>Logical separation based on message domains:</h4><br />
      One xmlBlaster instance can be the master for selective messages (e.g. for
      stock exchange messages) and be slave for other messages (e.g. for 
      air traffic radar tracks or rugby news) simultaneously, we call that <i>cluster message domains</i>.
      Consequently a client interested in all informations only needs to connect
      to one xmlBlaster server instance.
      <p>
      <img src="cluster.domain.gif" border="0" title="XmlBlaster cluster example" alt="Example for a typical xmlBlaster cluster" />
      </p>
      <p>
      As we can see the node <i>golan</i> is master of messages of the domain "STOCK_EXCHANGE" but
      caches "RUGBY_NEWS" as well.
      </p>
      </li>
      <li><h4>Load balancing:</h4><br />
      An xmlBlaster cluster allows to have more than one master server for
      a specific message type. The master nodes are <i>mirrored</i> instances
      for those messages.
      Published messages reach all master nodes.
      Subscribed messages are retrieved using a load balance algorithm.
      <p>
      <img src="cluster.loadbalance.gif" border="0" title="XmlBlaster cluster example" alt="Example for a typical xmlBlaster cluster" />
      </p>
      <p>
      In the above scenario heron1 and heron2 share their knowledge.
      Slave nodes can choose which of those servers to use.
      </p>
      </li>
      </ol>

      <hr />


      <h3>
      Implementation overview:
      </h3>
      
      <p>
      We have to code and manage two logical mapping functionalities:
      </p>
      <ol>
         <li><h4>Find out who is the master of a message</h4><br />
         We have a message and need to map it to a master.
         The decision can be based on any information in the message.
         As a default we supply a domain based approach:
         An XML attribute <i>domain</i> is used with the
         message &lt;key> tag, for example:<br />
         <pre>&lt;key domain='STOCK_EXCHANGE'/></pre>
         The domain based approach maps domain names to cluster node IDs.
         Please see the examples below.
         </li>
         <li><h4>Map a cluster node ID to the physical xmlBlaster instance</h4><br />
         After step 1. we need to find out how to reach the physical xmlBlaster instance.
         We have its cluster node ID and need to get the CORBA IOR, XmlRpc URL,
         RMI registry entry or the socket to be able to communicate.
         </li>
      </ol>
      
      <br />
      <p>
      The cluster specific features are
      </p>
            
      <ul>
      <li>Multi xmlBlaster instances<br />
      If multiple xmlBlaster servers are running, every message is assigned to exactly one
      master server (if no load balancing is switched on).
      The different xmlBlaster servers login to each other like other clients
      and act as slave to messages which they are not master from.
      </li>

      <li>Connections between xmlBlaster instances<br />
      This login is done in 'lazy' mode. As soon as a client requests a message
      for which the local server is not master, this server does a login to the master
      and subscribes the message from there. The message is than cached locally and further
      local requests from clients are handled locally.
      An adjustable expire date clears the cached message.
      </li>

      <li>Routing of published messages<br />
      If a message is published from a data source to a slave server, the message is routed directly
      to the master server (which may be a slave as well, forwarding the message to the real master).
      If the master server is currently offline, it is queued
      for this 'client' until it logs in.
      </li>

      <li>Plugin interface for master discovery<br />
      XmlBlaster supplies a plugin interface for your own logic to identify the master cluster node id.
      The default implementation uses the
      <pre>&lt;key domain='RUGBY'></pre> attribute (see examples below).
      </li>

      <li>Plugin interface for load balancing logic<br />
      XmlBlaster supplies a plugin interface for the load balancing logic.
      The default load balancing logic uses the round robin approach.
      </li>

      <li>Default master<br />
      The xmlBlaster node is domain master for its directly connected clients
      as a default. If a client is publishing/subscribing etc. without an
      explicitly specified domain, the messages are handled in the local
      xmlBlaster instance (as if no cluster is existing).
      If domain='NO_DEFAULT' is set another node is searched which
      accepts default messages.
      </li>
      <li>Master unknown<br />
      If a node receives a messages and can't find the master,
      the message is accepted and queued for the master.
      If later a master appears the messages are flushed.
      </li>
      <li>Multiple masters for same domain<br />
      If multiple nodes acquire the master mode for a certain domain
      there are to approaches.<br />
      Messages which are published are sent to all masters.<br />
      Messages which are accessed with get() or subscribe() are handled
      by the load balancing algorithm. The default implementation is a round robin.
      </li>
      </ul>
   </description>
   <example lang="Java">
      <![CDATA[
      <key oid='__sys__cluster.node:heron'>
         <__sys__cluster.node/>
      </key>

   content=
      <clusternode id='heron'>
         <address type='IOR'>IOR:00044550005...</address>
         <address type='XML-RPC'>http:/www.mars.universe:8080/RPC2</address>
         <callback type='XML-RPC'>http:/www.mars.universe:8081/RPC2</callback>
         <backupnode>
            <clusternode id='avalon'/>  <!-- first failover node -->
            <clusternode id='golan'/>   <!-- second backup node -->
         </backupnode>
         <nameservice>true</nameservice>
      </clusternode>



      <key oid='__sys__cluster.node.state:heron'>
         <__sys__cluster.node.state/>
      </key>
 
   content=
      <clusternode id='heron'>
         <state>
            <cpu id='0' idle='40'/>            <!-- currently 60% load on first CPU -->
            <cpu id='1' idle='44'/>
            <ram free='12000'/>                <!-- xmlBlaster server instance has 12 MB free memory -->
            <performance bogomips='1205.86'/>
         </state>
      </clusternode>



      <key oid='__sys__cluster.node.master:heron'>
         <__sys__cluster.node.master/>
      </key>
 
   content=
      <clusternode id='heron'>
         <master>
            <key domain=''/>           <!-- default setting -->
            <key domain='football'/>
            <key domain='rugby'/>
         </master>
      </clusternode>

      <clusternode id='frodo'>
         <master>
            <key domain='NO_DEFAULT'/> <!-- forward empty domains -->
            <key oid='radar.track'/>
            <key queryType='XPATH'>
               //STOCK_EXCHANGE
            </key>
         </master>
      </clusternode>


   A message can specify its domain as a key attribute:

      <key oid='football.49.results' domain='football'/>

   One or many domains are mapped to a cluster node ID (the master name).
      ]]>
   </example>
   <author>ruff@swand.lake.de</author>
   <author>Heinrich.Goetzger@exploding-systems.de</author>
   <date>2000 04 03</date>
   <revision>$Revision: 1.10 $</revision>
   <testcase status="OPEN">
      <name>-</name>
      <comment>-</comment>
      <test tool="SUITE"></test>
   </testcase>
</requirement>

