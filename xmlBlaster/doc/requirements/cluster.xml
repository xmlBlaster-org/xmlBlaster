<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='cluster' type='NEW' prio='HIGH' status="OPEN">
   <topic>Multiple xmlBlaster instances can build a cluster following the master/slave paradigm</topic>
   <description>
      <p>
      We define a cluster as a configuration where more than one xmlBlaster
      server instance is running. The instances may run on the same host or
      distributed over the internet.
      </p>
      <p>
      All clustering abilities for xmlBlaster reduce to the simple master/slave approach.
      The cluster approach is easy to understand as we are not leaving the MoM paradigm
      to support clustering.
      </p>
      <p>
      An important part in clustering is the <i>discovery and lookup</i>.
      How to find other cluster nodes and access in depth
      node informations from them, and how to keep those informations up to date.
      This is addressed with the publish/subscribe idea as well.
      XmlBlaster nodes store their cluster informations in messages, so other nodes
      can subsrcribe to this data. If necessary one xmlBlaster is running as a 'naming service'
      holding the informations of all available xmlBlaster instances.
      </p>
      <p>
      In the following examples, we use the term <i>xmlBlaster server instance</i> and
      <i>xmlBlaster node</i> or just <i>node</i> interchangeable.
      </p>
      <center><p>
      <img src="cluster.gif" border="0" title="XmlBlaster cluster example" alt="Example for a typical xmlBlaster cluster" />
      </p></center>
      <p>
      In this example we have three xmlBlaster instances running, each of them has
      a unique ID, here the names <i>golan</i>, <i>heron</i> and <i>avalon</i>.
      </p>
      <p>
      Each of the nodes have an arbitrary number of clients attached. The clients
      can publish or subscribe to any message in the cluster, and may send PtP messages
      to any other client.
      </p>
      
      <hr />

      <h3>
      Clustering in our sense covers the following topics:
      </h3>
      <ol>
      <li><h4>Scalability (Load balancing):</h4><br />
      An xmlBlaster server instance allows to have any number of slave xmlBlaster server instances
      for specific message types. These slaves can have further slaves again.
      This allows distributing messages to an almost unlimited number of clients.
      Note that one xmlBlaster node can be a master for some messages and a slave for
      other message types simultaneously.
      <p>
      <img src="cluster.scalability.gif" border="0" title="XmlBlaster cluster example" alt="Example for a typical xmlBlaster cluster" />
      </p>
      <p>
      The example shows a tree like configuration of xmlBlaster nodes. In this way
      we can connect an almost unlimited number of clients. Every child leaf supplies
      a certain amount of slaves, which supplies other slaves which finally supply
      clients with message updates. The slaves are caching the messages and respond to
      request of their clients directly. With every child level in the tree the latency increases
      for typically 5-40 milliseconds (intranet) for new published message updates.
      Note that the publisher does not need to be connected to the master node, the client in the
      down left edge of the picture is publishing as well.
      </p>
      </li>
      <li><h4>Availability (Failover):</h4><br />
      An xmlBlaster slave may adopt the master role for selective message types
      if the current xmlBlaster master fails.
      <p>
      <img src="cluster.availability.gif" border="0" title="XmlBlaster cluster example" alt="Example for a typical xmlBlaster cluster" />
      </p>
      </li>
      <li><h4>Logical separation based on message domains:</h4><br />
      One xmlBlaster instance can be the master for selective messages (e.g. for
      stock exchange messages) and be slave for other messages (e.g. for 
      air traffic radar tracks or rugby news) simultaneously. Consequently a client interested
      in all informations only needs to connect to one xmlBlaster server instance.
      <p>
      <img src="cluster.topic.gif" border="0" title="XmlBlaster cluster example" alt="Example for a typical xmlBlaster cluster" />
      </p>
      <p>
      As we can see the node <i>golan</i> is master of messages of the domain "STOCK_EXCHANGE" but
      caches "RUGBY_NEWS" as well.
      </p>
      </li>
      </ol>

      <hr />


      <h3>
      Implementation overview:
      </h3>
      <p>
      If multiple xmlBlaster servers are running, every message is assigned to exactly one
      master server. The different xmlBlaster servers login to each other like other clients
      and act as slave to messages which they are not master from.
      </p>
      <p>
      This login is done in 'lazy' mode. As soon as a client requests a message
      for which the local server is not master, this server does a login to the master
      and subscribes the message from there. The message is than cached locally and further
      local requests from clients are handled locally.
      An adjustable expire date clears the cached message.
      </p>
      <p>
      If a message is published from a data source to a slave server, the message is routed directly
      to the master server (which may be a slave as well, forwarding the message to the real master).
      If the master server is currently offline, it is queued
      for this 'client' until it logs in.
      </p>

      <ul>
      <li>Default master<br />
      The 
      </li>
      <li>Master unknown<br />
      If a node receives a messages and can't find the master,
      the message is accepted and queued for the master.
      If later a master appears the messages are flushed.
      </li>
      </ul>
   </description>
   <example lang="Java">
      <![CDATA[
      <key oid='__sys__cluster.node:heron'>
         <__sys__cluster.node/>
      </key>

   content=
      <clusternode id='heron'>
         <address type='IOR'>IOR:00044550005...</address>
         <address type='XML-RPC'>http:/www.mars.universe:8080/RPC2</address>
         <callback type='XML-RPC'>http:/www.mars.universe:8081/RPC2</callback>
         <backupnode>
            <clusternode id='avalon'/>  <!-- first failover node -->
            <clusternode id='golan'/>   <!-- second backup node -->
         </backupnode>
         <nameservice>true</nameservice>
      </clusternode>



      <key oid='__sys__cluster.node.state:heron'>
         <__sys__cluster.node.state/>
      </key>
 
   content=
      <clusternode id='heron'>
         <state>
            <cpu id='0' idle='40'/>            <!-- currently 60% load on first CPU -->
            <cpu id='1' idle='44'/>
            <ram free='12000'/>                <!-- xmlBlaster server instance has 12 MB free memory -->
            <performance bogomips='1205.86'/>
         </state>
      </clusternode>



      <key oid='__sys__cluster.node.master:heron'>
         <__sys__cluster.node.master/>
      </key>
 
   content=
      <clusternode id='heron'>
         <master>
            <key domain=''/>           <!-- default setting -->
            <key domain='football'/>
            <key domain='rugby'/>
         </master>
      </clusternode>

      <clusternode id='frodo'>
         <master>
            <key domain='NO_DEFAULT'/> <!-- forward empty domains -->
            <key oid='radar.track'/>
            <key queryType='XPATH'>
               //STOCK_EXCHANGE
            </key>
         </master>
      </clusternode>


   A message can specify its domain as a key attribute:

      <key oid='football.49.results' domain='football'/>

   One or many domains are mapped to a cluster master name.
   The 
      ]]>
   </example>
   <author>ruff@swand.lake.de</author>
   <date>2000 04 03</date>
   <revision>$Revision: 1.7 $</revision>
   <testcase status="OPEN">
      <name>-</name>
      <comment>-</comment>
      <test tool="SUITE"></test>
   </testcase>
</requirement>

