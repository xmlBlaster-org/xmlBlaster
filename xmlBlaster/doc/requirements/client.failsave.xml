<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='client.failsave' type='NEW' prio='LOW' status="INWORK">
   <topic>
      XmlBlasterConnection is a helper class for Java clients which supports
      polling for xmlBlaster and record/playback of messages during lost connections.
   </topic>
   <description>
      <p>
      We discuss in this requirements the strategy used by clients to connect
      to an xmlBlaster server. The same strategy is used by an xmlBlaster server
      to callback to a client.
      </p>

      <br />
      <h2>Standard client connection</h2>
      <p>
      Lets have a look at the states of a client connection without any fail save behaviour:
      </p>
      <br />
      <img src="ConnectionLifeCycleStatusDiagramNotFailSave.gif" border="0" title="Standard lifecycle of a remote connection as seen by a client" alt="Standard lifecycle of a remote connection as seen by a client" />
      <br />
      <p>
      On startup a client tries to connect to xmlBlaster and if xmlBlaster is not found we get an exception.
      Every client developer needs to code her own strategy how to poll for xmlBlaster in such a case.
      </p>

      <br />
      <h2>Fail save mode</h2>
      <p>
      In fail save mode the status diagram of a client connection (and similar a callback connection in xmlBlaster)
      is a bit more complicated, but you should remember that you have to solve these problems
      in any distributed environment, if we don't address it here you have to invent it yourself:
      </p>
      <br />
      <img src="ConnectionLifeCycleStatusDiagram.gif" border="0" title="Fail save lifecycle of a remote connection as seen by a client" alt="Fail save lifecycle of a remote connection as seen by a client" />
      <br />
      <p>
      As you can see, a client connection has three states namely <i>connected</i>, <i>polling</i> and <i>dead</i>.
      </p>
      <p>
      On startup a client tries to connect to xmlBlaster and one of the state transitions (1), (2) or (3) happens:
      The client connects successfully, the client library polls for a connection or we receive an exception.
      </p>
      <p>
      After a connection is established we may loose the connection and depending on our
      configuration parameters we start polling (4) or we give up (7), if we are tired to
      poll we give up as well (6).
      </p>
      <p>
      If we are in <i>dead</i> state, the transitions (8) and (9) show recovery possibilities.
      We could change the configuration in <i>dead</i> state, for example
      we could supply another address to find xmlBlaster. Note that this feature is
      currently NOT implemented (marked with blue color).
      </p>
      <p>
      The method names (marked green in the drawing) are events which the client developer
      may listen on to do specific handling depending on the situation.
      </p>

      <br />
      <h2>
      What is a <b>pubSessionId</b>?
      </h2>
      <p>
      Every client which connects to xmlBlaster needs to supply a login name and optionally a public session identifier
      which identifies the login session. The session identifier is <i>public</i> as everybody may see it, in contrast
      there is private session id as well (which is generated by xmlBlaster) which is secret as anybody having this
      secret session ID could kidnap the connection.
      </p>
      <p>
      The following figure shows the session naming conventions.
      </p>
      <br />
      <img src="SessionNamingConvention.gif" border="0" title="Session naming convention" alt="Session naming convention" />
      <br />
      <p>
      A client which wants to login to xmlBlaster needs at least a <i>subjectId</i>. The
      <i>subjectId</i> is a login name which must be unique in a cluster. You may not
      choose '_', ':' or '/' characters in your <i>subjectId</i>.
      </p>
      <p>
      The public session identifier (<i>pubSessionId</i>) identifies every login session
      of a specific user. The scope of a <i>pubSessionId</i> is the <i>subjectId</i> - so a client
      with another login name may have the same public session ID.<br />
      The <i>pubSessionId</i> is an integer, negative numbers are reserved for xmlBlaster generated
      <i>pubSessionId</i> whereas a client may decide to choose a well known <i>pubSessionId</i>
      itself which must be a positive integer.
      </p>
      <p>
      Examples for valid <i>relative names</i>:
      </p>
      <pre>
   joe                  // xmlBlaster generates a pubSessionId for us
   jack@xy.com/4        // the user 'jack@xy.com' wants to (re)connect to session 4
   averell/-2           // the second session if averell (pubSessionId is generated by xmlBlaster)
      </pre>
      <p>
      Note that the client administrator needs to take care if it manages the pubSessionId himself.
      If he by mistake starts two clients with the same <i>relative name</i> they operate on the
      same server side session object instance and may produce unpredictable results.
      </p>

      <br />
      <h2>
      Client connection scenarios in a cluster environment
      </h2>
      <p>
      The following figure illustrates typical environments where a client must
      find its server and recover failsave from lost connections.
      </p>
      <br />
      <img src="FailsaveConnectionInClusterEnvironment.gif" border="0" title="Failsave client connection in cluster environments" alt="Failsave client connection in cluster environments" />
      <br />
      <p>
      Above you see different cluster configurations which we discuss in detail later.
      The basic behind all scenarios is that the client need to more or less
      handle lost connections or lost sessions. If the client reconnects after
      failure there are two possibilities:
      </p>
      <ol>
       <li>The client gets a <b>new pubSessionId</b> which means that the session
       information of the client is lost in the server.<br />
       In this case the client it needs to reinitialize 
       all subscribes as on its startup. This sounds complicated but usually it
       is not too difficult to code an initialize method in the client which is
       invoked on startup or on reconnect.<br />
       If the xmlBlaster server would support to mirror the session information
       of clients in the cluster environment the client programmer would not
       need to remember its current subscribes.
       </li>
       <li>The client reconnects to the <b>same pubSessionId</b> which means
       it found its server side session info object again.
       This is the
       case if it found the same xmlBlaster server instance (and the session is not timed out)
       or if the xmlBlaster server instance have mirrored the session information of the client.
       </li>
      </ol>

      <p>
      Now we look at the different cluster configurations:
      </p>

      <h4>1. Independent server instance</h4>
      <p>
      A client needs to connect to only one xmlBlaster node, if the connection
      is lost we poll for the same server as configured on startup.
      </p>
      <p>
      </p>

      <h4>2. Cluster collective with mirrored nodes</h4>
      <p>
      The client polls for two servers, if it has connected to one it is happy.
      If the reconnect changed from say <i>sauron</i> to <i>smeagle</i>
      the session information is mirrored and the client does not need to reinitialize its
      startup subscriptions.
      </p>
      <p>
      In this case the client library must support multiple server addresses.
      </p>

      <h4>3. High availability (HA) cluster with mirrored nodes</h4>
      <p>
      If you have a smart system administrator she will install
      a high availability software on your servers. This allows to reuse the
      same IP address if one of your server hardware crashes.
      From the client view it always connects to the same IP even if the hardware
      behind changed. XmlBlaster needs to run mirrored so that all xmlBlaster server nodes
      have the statefull session informations.
      Usually the HA solution uses the same harddisks (say RAID 5 hotswappable)
      which makes it easy for the xmlBlaster cluster nodes to share their persistent data.
      </p>
      <p>
      An example for a commercial HA solution is <i>ServiceGuard</i> from HP.
      </p>

      <h4>4. Master/slave cluster setup</h4>
      <p>
      In this setup no stateful session information is mirrored. If a client goes
      to the other node it needs to reinitialize its subscriptions.
      Note that all messages are available on both nodes as the operate in master/slave mode.
      </p>

      <p>
      Note: The protocol used (CORBA, RMI, XML-RPC etc.) is transparently hidden.
      See XmlBlasterConnection.java for a usage description and TestFailSave.java (testsuite)
      for a code example how to use it.
      </p>
   </description>
   <example lang="Java">
      <![CDATA[
// Example with default fail save settings,
// you can change these on command line or in a property file.
// See configuration section below
try {
   con = new XmlBlasterConnection(glob);

   con.initFailSave(new I_ConnectionProblems() {
         
         public void reConnected() {
            log.info(ME, "I_ConnectionProblems: We were lucky, reconnected to " + glob.getId());
            //initClient();    // initialize subscription etc. again
            try {
               con.flushQueue();    // send all tailback messages
               // con.resetQueue(); // or discard them (it is our choice)
            } catch (XmlBlasterException e) {
               log.error(ME, "Exception during reconnection recovery: " + e.reason);
            }
         }

         public void lostConnection() {
            log.warn(ME, "I_ConnectionProblems: Lost connection to " + glob.getId());
         }
      });

   ConnectQos qos = new ConnectQos(glob);

   ConnectReturnQos conRetQos = con.connect(qos, new I_Callback() {
      public String update(String cbSessionId, UpdateKey updateKey, byte[] content,
                                                               UpdateQos updateQos) {
         log.info(ME, "Reveiving asynchronous message '" + updateKey.getOid() + "'");
         return "";
      }
   });  // Login to xmlBlaster, default handler for updates

   log.info(ME, "Connected to xmlBlaster.");
   ...
      ]]>
   </example>

   <example lang="Java">
      <![CDATA[
import org.xmlBlaster.engine.helper.Address;

// Example with hard coded fail save settings
// Here the callback methods are not shown
try {
   con = new XmlBlasterConnection(glob); // Find orb

   ConnectQos connectQos = new ConnectQos(glob, loginName, passwd);

   // Setup fail save handling ...
   Address addressProp = new Address(glob);
   addressProp.setDelay(4000L);      // retry connecting every 4 sec
   addressProp.setRetries(-1);       // -1 == forever
   addressProp.setPingInterval(0L);  // switched off
   addressProp.setMaxMsg(1000);      // queue up to 1000 messages
   con.initFailSave(this);

   connectQos.setAddress(addressProp);

   // and do the login ...
   con.connect(connectQos, this);  // Login to xmlBlaster, register for updates
}
catch (XmlBlasterException e) {
      Log.warn(ME, "setUp() - login failed");
      fail("setUp() - login faile");
}
 
      ]]>
   </example>

   <configuration where="server">
      <p>
      These parameters allow to configure the clients fail save behavior.
      </p>
      <p>
      Example:
      <pre>java HelloWorld4 -queue.maxMsg 20000</pre>
      </p>
      <table border="1">
         <tr>
            <th>Property</th>
            <th>Default / Example</th>
            <th>Description</th>
            <th>Implemented</th>
         </tr>

         <tr>
            <td>pingInterval</td>
            <td>10000</td>
            <td>Ping every given milliseconds if xmlBlaster connection is OK</td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>retries</td>
            <td>-1 (forever)</td>
            <td>How often to retry to establish a new connection to xmlBlaster
                on failure.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>delay</td>
            <td>4000</td>
            <td>Delay between connection retries in milliseconds<br />
                A delay value > 0 switches fails save mode on, 0 switches it off</td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
         
         <tr>
            <td>queue.maxMsg</td>
            <td>1000</td>
            <td>The maximum allowed number of messages in this queue<br />
                0 switches recording of invocations (tail back messages) off.<br />
                -1 sets it to unlimited.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
      </table>
   </configuration>

   <see type="REQ">client.failsave.ping</see>
   <see type="REQ">util.recorder</see>
   <see type="REQ">util.recorder.persistence</see>
   <see type="API">org.xmlBlaster.client.protocol.XmlBlasterConnection</see>
   <author>ruff@swand.lake.de</author>
   <hacker>ruff@swand.lake.de</hacker>
   <date>2000 02 23</date>
   <revision>$Revision: 1.20 $</revision>
   <testcase status="CLOSED">
      <name>-</name>
      <comment>-</comment>
      <test tool="SUITE">org.xmlBlaster.test.qos.TestFailSave</test>
      <test tool="SUITE">org.xmlBlaster.test.qos.TestInvocationRecorder</test>
      <test tool="SUITE">org.xmlBlaster.test.qos.TestFailSaveAsync</test>
      <test tool="SUITE">org.xmlBlaster.test.classtest.InvocationRecorderTest</test>
   </testcase>
</requirement>

