/*
Name:      xmlBlaster.idl
Project:   xmlBlaster.org
Task:      Serverinterface
Copyright: xmlBlaster.org, see xmlBlaster-LICENSE file
Comment:   Not even alpha
           String arguments my be used empty "", but never with null
Compile:   JacORB:
             /usr/local/JacORB/bin/idl -p org.xmlBlaster -d ${XMLBLASTER_HOME}/src/java xmlBlaster.idl
           VisiBroker:
             /usr/local/vbroker/bin/idl2java -root_dir ${XMLBLASTER_HOME}/src/java xmlBlaster.idl
           Mico:
             /usr/local/mico/bin/idl --poa --no-boa xmlBlaster.idl
Version:   $Id: xmlBlaster.idl,v 1.14 1999/11/16 18:44:45 ruff Exp $
================================================================================
*/

#ifndef _xmlBlaster_IDL_
#define _xmlBlaster_IDL_


#pragma prefix "org.xmlBlaster"

//------------------------------------------------------------------------------
//#include "xy.idl"
//------------------------------------------------------------------------------


/**
 * Decration of common types
 */
module serverIdl
{
   typedef string XmlType;
   typedef sequence<XmlType> XmlTypeArr;

   typedef sequence<octet> ContentType;
   typedef string ExceptionIdType;

   /**
    * This contains all informations about a Message and the Message itself.
    *
    * @param xmlKey  Unique message key with index attributes
    * @param content The data itself (XML data, java objects, jpeg pictures ...)
    */
   struct MessageUnit {
      XmlType xmlKey;
      ContentType content;
   };
   typedef sequence<MessageUnit> MessageUnitArr;

}; // org::xmlBlaster::serverIdl




/**
 * Decration of the client Callback interface.
 *
 * Declared before the server, so that the server declaration
 * can use the BlasterCallback interface
 *
 * Forward declaration like
 *    interface org::xmlBlaster::clientIdl::BlasterCallback;
 * didn't work!?
 */
module clientIdl
{
   /**
    * This interface needs to be implemented by the clients using
    * the AttributeServer
    * The IOR of this BlasterCallback has to be passed initially to the
    * xmlBlaster using the initCallback() method
    */
   interface BlasterCallback
   {
      /**
       * @param messageUnit Contains a sequence of 0 - n MessageUnit structs
       * @param qos         Qualitiy of Service for each MessageUnit
       */
     //oneway
     void update(in serverIdl::MessageUnitArr messageUnitArr,
                 in serverIdl::XmlTypeArr qosArr);
   };

}; // org::xmlBlaster::clientIdl



/**
 * The xmlBlaster interface
 */
module serverIdl
{
   /**
    * Exception class for xmlBlaster interface
    */
   exception XmlBlasterException
   {
      ExceptionIdType id;  // unique error code
      string reason;       // in english
   };


   /**
    * This is an easy to use, message based, non adressing communication
    * middleware interface.
    * <p>
    * It allows event-driven instant communication between sperate modules.<br>
    *
    * COMMENTS:
    *   It is generic to avoid future changes to the IDL.<br>
    *
    *   This server uses the benefits of both technologies XML and CORBA.<br>
    *
    *   It is a compromise between compile time type checking (CORBA)
    *   and runtime type checking (XML).<p>
    *
    *   Runtime checking allows easier maintenance and migration to newer
    *   xmlBlaster Versions, compile time checking of invariant interfaces
    *   allows enhanced performance and early error checking.
    *
    *   Authentication and Authorization is not supported, they will be
    *   provided as seperate servers.<p>
    *
    *   The <KEY id=""> strings have to be handled in a hierarchical manner to avoid
    *   namespace conflicts or may be generated (as number) by the xmlBlaster-server.
    *
    * BENEFITS:
    *   xmlBlaster allows instant communication between different uncoupled modules
    *   spread over the internet (publish / subscriber framework).
    *
    *   For example:
    *   - Clipboard functionality to store permanent the clipboard entries
    *     of many clients
    *   - Task handling
    *     This feature allows automatical notification, when a task
    *     for a special user is available.
    *   - Inter client communication (chat rooms, graphic rooms etc.)
    *   - Broadcasts over well known attribute-keys
    *     or by notifing all known client-callback interfaces
    *   - email like instant notifications
    *   - inter process 'model/view/controller' paradigm
    *   - synchronize html with embedded applets over the server
    *   - data and message transfer between subsystems
    *   - controler support functionality like subsystem-alive slots,
    *     start and stop events etc.
    *   - configuration attributes with auto-notification
    *   - Central logging facility for client/server systems
    *
    * RELATED DESIGN PATTERNS:
    *   @see JMS - Java Message Service, http://java.sun.com/products/jms/
    *   @see JNDI - Java Naming & Directory Interface, www.javasoft.com/products/jndi
    *   @see Observer Pattern, Gamma et.al
    *   @see CORBA Property Service, http://www.omg.org
    *   @see CORBA Notifiction Service ftp://ftp.omg.org/pub/docs/telecom/98-01-01.pdf
    *   @see CORBA Event Service (push/pull concepts), http://www.omg.org
    *   @see CORBA Design Patterns, Mowbray Thomas J. et al. 'Dynamic Attributes'
    *   @see Adressless message-event-middleware pattern
    */
   interface Server
   {
      /**
       * Asynchron read-access method
       * The result are returned to the
       * Client-Callback interface via the update() method.
       * You need to implement the method BlasterCallback.update(AttributeSeq)
       * This is the push modus.
       *
       * @param xmlKey  Key with attributes allowing Regex/XQL/SQL selection<br>
       *                See xmlKey.dtd for a description
       *                HACK: Send a (none XML) String key in this alfa release!!!
       * @param qos     Quality of Service, flags to control subscritpion<br>
       *                See qosSubscribe.dtd for a description
       *                HACK: Specify the ClientCallback String IOR here!!!
       */
      //oneway
      void subscribe(in XmlType xmlKey, in XmlType qos)
                                          raises(XmlBlasterException);


      /**
       * Synchron read-access methods
       * This is the pull modus.
       *
       * @param xmlKey  Key with attributes allowing Regex/XQL/SQL selection<br>
       *                See xmlKey.dtd for a description
       *                HACK: Send a (none XML) String key in this alfa release!!!
       * @param qos     Quality of Service, flags to control subscritpion<br>
       *                See qosSubscribe.dtd for a description
       *                HACK: Specify the ClientCallback String IOR here!!!
       * @return Contains a sequence of 0 - n MessageUnit structs
       */
      MessageUnitArr get(in XmlType xmlKey, in XmlType qos)
                                          raises(XmlBlasterException);


      /**
       * if a key was subscribed forever, you can cancel your
       * subscription with following method
       *
       * @param xmlKey    Key with attributes allowing Regex/XQL/SQL selection<br>
       *                  See xmlKey.dtd for a description
       * @param qos       Quality of Service, flags to control unsubscritpion<br>
       *                  See qosSubscribe.dtd for a description
       */
      //oneway
      void unSubscribe(in XmlType xmlKey, in XmlType qos)
                                          raises(XmlBlasterException);


      /**
       * Write-Access Method
       * This triggers the method update() if observed by somebody
       * If the given key doesn't exist, it will be automatically added, <br>
       * so this covers the SQL'ish INSERT and UPDATE.<p>
       *
       * For performance or transaction reasons, you can send a whole array
       * of MessageUnits with one Invokation of publish()
       *
       * @param messageUnit Contains a sequence of 0 - n MessageUnit structs
       * @param qos         Qualitiy of Service for each MessageUnit
       *
       * @return number of keys successfully set
       */
      //oneway
      long publish(in MessageUnitArr messageUnitArr, in XmlTypeArr qosArr)
                                          raises(XmlBlasterException);


      /**
       * erase an attribute
       * @return number of entries removed
       */
      long erase(in XmlType xmlKey, in XmlType qos)
                                          raises(XmlBlasterException);
   };

}; // org::xmlBlaster::serverIdl



/**
 * The xmlBlaster authentication interface.
 * <p>
 * Use this interface to access via login() the xmlBlaster
 */
module authenticateIdl
{
   interface AuthServer
   {
      /**
       * Login to server.
       * <p>
       * This is a factory for server interfaces
       *
       * @param loginName A unique name - Not yet necessary
       * @param passwd    Pasword - Not yet necessary
       * @param cb        Reference to the BlasterCallback interface or null for synchronous access
       * @param qos       Quality of Service, flags for additional client informations
       *                  like clientCertificate (X.509), timeouts etc.
       *
       * @return if the login is successfull, the xmlBlaster server interface is returned
       * @exception if the login fails
       */
      serverIdl::Server login(in string loginName, in string passwd,
                   in clientIdl::BlasterCallback cb,
                   in serverIdl::XmlType qosClient)
                      raises (serverIdl::XmlBlasterException);


      /**
       * Logout from server
       *
       * @param The server interface handle from the login() method
       */
      void logout(in serverIdl::Server xmlBlaster) raises (serverIdl::XmlBlasterException);
   };


}; // org::xmlBlaster::AuthenticateIdl



#endif // _xmlBlaster_IDL_
