/*
Name:      xmlBlaster.idl
Project:   xmlBlaster.org
Task:      Serverinterface
Copyright: LGPL http://www.gnu.org
           $Id: xmlBlaster.idl,v 1.7 1999/11/12 13:07:01 ruff Exp $
Comment:   Not even alpha
           String arguments my be used empty "", but never with null
Compile:   idl2java -root_dir ../../classes xmlBlaster.idl
================================================================================
*/

#ifndef _xmlBlaster_IDL_
#define _xmlBlaster_IDL_


//------------------------------------------------------------------------------
//#include "xy.idl"
//------------------------------------------------------------------------------


/**
 * Decration of common types
 */
module org { module xmlBlaster { module serverIdl
{
   typedef string XmlType;
   typedef sequence<octet> ContentType;
   typedef string ExceptionIdType;

   struct MessageUnit {
      XmlType xmlKey;
      ContentType content;
   };
   typedef sequence<MessageUnit> MessageUnitArr;

}; }; }; // org::xmlBlaster::serverIdl




/**
 * Decration of the client Callback interface. 
 * Declared before the server, so that the server declaration
 * can use the BlasterCallback interface
 *
 * Forward declaration like
 *    interface org::xmlBlaster::clientIdl::BlasterCallback;
 * didn't work!?
 */
module org { module xmlBlaster { module clientIdl
{
   /**
    * This interface needs to be implemented by the clients using
    * the AttributeServer
    * The IOR of this BlasterCallback has to be passed initially to the
    * xmlBlaster using the initCallback() method
    */
   interface BlasterCallback
   {
      /**
       * @param xmlKey  Key<br>
       * @param qos     Quality of Service<br>
       *                <notify/>    Notifying only about change (content is empty)
       *                <metaInfo/>  xmlKey contains all known meta information
       *                <noAccess/>  Permission denied
       *                <destroyed/> MessageUnit got erased
       */
     //oneway
     void update(in org::xmlBlaster::serverIdl::XmlType xmlKey,
                 in org::xmlBlaster::serverIdl::ContentType content,
                 in org::xmlBlaster::serverIdl::XmlType qos);
   };

}; }; }; // org::xmlBlaster::clientIdl




/**
 * The xmlBlaster interface
 */
module org { module xmlBlaster { module serverIdl
{
   /**
    * Exception class for xmlBlaster interface
    */
   exception XmlBlasterException
   {
      ExceptionIdType id;  // unique error code
      string reason;       // in english
   };


   /**
    * This is an easy to use, message based, non adressing communication
    * middleware interface.
    * <p>
    * It allows event-driven instant communication between sperate modules.<br>
    *
    * COMMENTS:
    *   It is generic to avoid future changes to the IDL.<br>
    *
    *   This server uses the benefits of both technologies XML and CORBA.<br>
    *
    *   It is a compromise between compile time type checking (CORBA)
    *   and runtime type checking (XML).<p>
    *
    *   Runtime checking allows easier maintenance and migration to newer
    *   xmlBlaster Versions, compile time checking of invariant interfaces
    *   allows enhanced performance and early error checking.
    *
    *   Authentication and Authorization is not supported, they will be
    *   provided as seperate servers.<p>
    *
    *   The <KEY id=""> strings have to be handled in a hierarchical manner to avoid
    *   namespace conflicts or may be generated (as number) by the xmlBlaster-server.
    *
    * BENEFITS:
    *   xmlBlaster allows instant communication between different uncoupled modules
    *   spread over the internet (publish / subscriber framework).
    *
    *   For example:
    *   - Clipboard functionality to store permanent the clipboard entries
    *     of many clients
    *   - Task handling
    *     This feature allows automatical notification, when a task
    *     for a special user is available.
    *   - Inter client communication (chat rooms, grahic rooms etc.)
    *   - Broadcasts over well known attribute-keys
    *     or by notifing all known client-callback interfaces
    *   - email like instant notifications
    *   - inter process 'model/view/controller' paradigm
    *   - synchronize html with embedded applets over the server
    *   - data and message transfer between subsystems
    *   - controler support functionality like subsystem-alive slots,
    *     start and stop events etc.
    *   - configuration attributes with auto-notification
    *
    * RELATED DESIGN PATTERNS:
    *   @see Java Message Service, http://java.sun.com/products/jms/
    *   @see Java Naming & Directory Interface, www.javasoft.com/products/jndi
    *   @see Observer Pattern, Gamma et.al
    *   @see CORBA Property Service, http://www.omg.org
    *   @see CORBA Notifiction Service ftp://ftp.omg.org/pub/docs/telecom/98-01-01.pdf
    *   @see CORBA Event Service (push/pull concepts), http://www.omg.org
    *   @see CORBA Design Patterns, Mowbray Thomas J. et al. 'Dynamic Attributes'
    *   @see Adressless message-event-middleware pattern
    */
   interface Server
   {
      /**
       * Login to server
       * @param loginName A unique name - Not yet necessary
       * @param passwd    Pasword - Not yet necessary
       * @param cb        Reference to the BlasterCallback interface or null for synchronous access
       * @param qos       Quality of Service, flags for additional client informations
       *                  like clientCertificate (X.509), timeouts etc.
       * @return sessionId The unique identifier for the client
       */
      string login(in string loginName, in string passwd,
                   in org::xmlBlaster::clientIdl::BlasterCallback cb,
                   in XmlType qos) raises (XmlBlasterException);


      /**
       * Login to server
       * @param sessionId The client identifier, obtained from login()
       */
      void logout(in string sessionId) raises (XmlBlasterException);


      /**
       * Asynchron read-access methods
       * The result are returned to the
       * Client-Callback interface via the update() method.
       * If you wish automatical updates when changes occur,
       * please register yourself with your Observable
       * Tell your own Interface Callback IOR initially using initCallback()
       * and implement the method update(AttributeSeq)
       * This is the push modus.
       *
       * @param xmlKey  Key with attributes allowing Regex/XQL/SQL selection<br>
       *                See xmlKey.dtd for a description
       *                HACK: Send a (none XML) String key in this alfa release!!!
       * @param qos     Quality of Service, flags to control subscritpion<br>
       *                See qosSubscribe.dtd for a description
       *                HACK: Specify the ClientCallback String IOR here!!!
       */
      //oneway
      void subscribe(in string sessionId, in XmlType xmlKey, in XmlType qos)
                                          raises(XmlBlasterException);


      /**
       * Synchron read-access methods
       *
       * @param xmlKey  Key with attributes allowing Regex/XQL/SQL selection<br>
       *                See xmlKey.dtd for a description
       *                HACK: Send a (none XML) String key in this alfa release!!!
       * @param qos     Quality of Service, flags to control subscritpion<br>
       *                See qosSubscribe.dtd for a description
       *                HACK: Specify the ClientCallback String IOR here!!!
       * @return the content
       */
      ContentType get(in string sessionId, in XmlType xmlKey, in XmlType qos)
                                          raises(XmlBlasterException);


      /**
       * if a key was subscribed forever, you can cancel your
       * subscription with following method
       *
       * @param sessionId The client identifier, obtained from login()
       * @param xmlKey    Key with attributes allowing Regex/XQL/SQL selection<br>
       *                  See xmlKey.dtd for a description
       * @param qos       Quality of Service, flags to control unsubscritpion<br>
       *                  See qosSubscribe.dtd for a description
       */
      //oneway
      void unSubscribe(in string sessionId, in XmlType xmlKey, in XmlType qos)
                                          raises(XmlBlasterException);


      /**
       * Write-Access Method
       * This triggers the method update() if observed by somebody
       * If the given key doesn't exist, it will be automatically added, <br>
       * so this covers the SQL'ish INSERT and UPDATE
       *
       * @param xmlKey  Key with attributes allowing Regex/XQL/SQL selection<br>
       * @param content The data to store (XML data, java objects, ...)
       * @param qos     Qualitiy of Service which is supported by the xmlBlaster server<br>
       *                or by its plugin (XML formated)
       *
       * @return number of keys successfully set
       */
      long publish(in string sessionId, in XmlType xmlKey, in ContentType content, in XmlType qos)
                                          raises(XmlBlasterException);


      /**
       * erase an attribute
       * @return number of entries removed
       */
      long erase(in string sessionId, in XmlType xmlKey, in XmlType qos)
                                          raises(XmlBlasterException);


   };

}; }; }; // org::xmlBlaster::serverIdl



#endif // _xmlBlaster_IDL_
