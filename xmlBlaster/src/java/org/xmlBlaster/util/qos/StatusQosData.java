/*------------------------------------------------------------------------------
Name:      StatusQosData.java
Project:   xmlBlaster.org
Copyright: xmlBlaster.org, see xmlBlaster-LICENSE file
------------------------------------------------------------------------------*/
package org.xmlBlaster.util.qos;

import org.xmlBlaster.util.Global;
import org.xmlBlaster.util.enum.Constants;


/**
 * Data container handling of status returned by subscribe(), unSubscribe(), erase() and ping(). 
 * <p>
 * This data holder is accessible through decorators, each of them allowing a specialized view on the data:
 * </p>
 * <ul>
 * <li>SubscribeReturnQos Returned QoS of a subscribe() invocation (Client side)</i>
 * <li>UnSubscribeReturnQos Returned QoS of a unSubscribe() invocation (Client side)</i>
 * <li>EraseReturnQos Returned QoS of an erase() invocation (Client side)</i>
 * </ul>
 * <p>
 * For the xml representation see StatusQosSaxFactory.
 * </p>
 * @see org.xmlBlaster.util.qos.StatusQosSaxFactory
 * @see org.xmlBlaster.test.classtest.qos.StatusQosFactoryTest
 * @author xmlBlaster@marcelruff.info
 */
public final class StatusQosData implements java.io.Serializable, Cloneable
{
   private String ME = "StatusQosData";
   private transient final Global glob;
   private transient final I_StatusQosFactory factory;
   private transient final String serialData;

   /** the state of the message, defaults to "OK" if no state is returned */
   private String state = Constants.STATE_OK;
   private String stateInfo;

   /** The subscription ID of a subscribe() invocation */
   private String subscriptionId;

   /** The key oid of a publish(), helpful if the oid was generated by xmlBlaster */
   private String keyOid;

   /**
    * Constructs the specialized quality of service object for status informations,
    * e.g. for a return of a subscribe() call
    * <p>
    * The state defaults to Constants.STATE_OK
    * </p>
    * @param The factory which knows how to serialize and parse me
    */
   public StatusQosData(Global glob) {
      this(glob, null, null);
   }

   /**
    * Constructs the specialized quality of service object for status informations,
    * e.g. for a return of a subscribe() call
    * @param The factory which knows how to serialize and parse me
    */
   public StatusQosData(Global glob, I_StatusQosFactory factory) {
      this(glob, factory, null);
   }

   /**
    * Constructs the specialized quality of service object for a publish() call.
    * For internal use only, this message is sent from the persistence layer
    * @param the XML based ASCII string
    * @param true
    */
   public StatusQosData(Global glob, I_StatusQosFactory factory, String serialData) {
      this.glob = glob;
      this.factory = (factory==null) ? glob.getStatusQosFactory() : factory;
      this.serialData = serialData;
   }

   /**
    * The unparsed data. 
    */
   public String getData() {
      return this.serialData;
   }

   /**
    * @param state The state of an update message. See Constants.java
    */
   public void setState(String state) {
      this.state = state;
   }

   /**
    * Access state of message on update().
    * @return "OK", "ERROR" etc. See Constants.java
    */
   public String getState() {
      return this.state;
   }

   /**
    * True if the message is OK on update(). 
    */
   public boolean isOk() {
      return Constants.STATE_OK.equals(this.state);
   }

   /**
    * True if the message was erased by timer or by a
    * client invoking erase(). 
    */
   public boolean isErased() {
      return Constants.STATE_ERASED.equals(this.state);
   }

   /**
    * True if a timeout on this message occurred. 
    * <p />
    * Timeouts are spanned by the publisher and thrown by xmlBlaster
    * on timeout to indicate for example
    * STALE messages or any other user problem domain specific event.
    */
   public final boolean isTimeout() {
      return Constants.STATE_TIMEOUT.equals(this.state);
   }

   /**
    * True on cluster forward problems
    */
   public final boolean isForwardError() {
      return Constants.STATE_FORWARD_ERROR.equals(this.state);
   }

   /**
    * @param state The human readable state text of an update message
    */
   public void setStateInfo(String stateInfo) {
      this.stateInfo = stateInfo;
   }

   /**
    * Access state of message on update().
    * @return The human readable info text
    */
   public String getStateInfo() {
      return this.stateInfo;
   }

   /**
    * If Pub/Sub style update: contains the subscribe ID which caused this update
    * @param subscriptionId null if PtP message
    */
   public void setSubscriptionId(String subscriptionId) {
      this.subscriptionId = subscriptionId;
   }

   /**
    * If Pub/Sub style update: contains the subscribe ID which caused this update
    * @return subscribeId or null if PtP message
    */
   public String getSubscriptionId() {
      return this.subscriptionId;
   }

   /**
    * Access key oid. 
    * @return The unique identifier of a message
    */
   public String getKeyOid() {
      return this.keyOid;
   }

   /**
    * Access unique oid of a message topic. 
    */
   public void setKeyOid(String oid) {
      this.keyOid = oid;
   }

   /**
    * The size in bytes of the data in XML form. 
    */
   public int size() {
      return toXml().length();
   }

   /**
    * Dump state of this object into a XML ASCII string.
    * <br>
    * @return internal state of the status as a XML ASCII string
    */
   public String toXml() {
      return toXml((String)null);
   }

   /**
    * Dump state of this object into a XML ASCII string.
    * <br>
    * @param extraOffset indenting of tags for nice output
    * @return internal state of the status as a XML ASCII string
    */
   public String toXml(String extraOffset) {
      return factory.writeObject(this, extraOffset);
   }

   /*
   public static String toXml(String state, String stateInfo, String subscriptionId, String keyOid) {
      // hack to use directly SaxFactory to avoid object creation
      // if in future we want to support other formats (not XML) we need to go the usual way over 'new StatusQosData'
      return org.xmlBlaster.util.qos.StatusQosSaxFactory.writeObject_(state, stateInfo, subscriptionId, keyOid, null);
   }
   */

   /**
    * Returns a shallow clone, you can change savely all basic or immutable types
    * like boolean, String, int.
    */
   public Object clone() {
      try {
         return super.clone();
      }
      catch (CloneNotSupportedException e) {
         return null;
      }
   }
}
