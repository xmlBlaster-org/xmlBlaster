---------------------------------------------------------------------
  C based SOCKET access to xmlBlaster, May 2003
---------------------------------------------------------------------

This is a first, tiny quick hack of a C based SOCKET client.
It should compile on Linux, Windows (PocketPC, WinCE) and other UNIX OS.

Features:

  o Support on many OS (Win, Win-CE, UNIX, Linux) and easy portable

  o Compiles with C or with C++ compiler

  o Object size only ~25 KBytes
  
  o Supports synchronous xmlBlaster access with
    connect(), disconnect(), get(), publish(), erase(), ping()
  
  o Asynchronous access with client callback update() is under
    development
    Posix threads DLL for Win, PocketPC, WinCE:
       http://sources.redhat.com/pthreads-win32

  o Reports exception nicely back to the client

  o The client side xmlBlasterAccess structure has function pointers
    for all methods to have object oriented like access,
    see client.c as a usage example

  o The access library and the callback library is thread safe.
    Multiple instances of client connections or callback servers
    can run in parallel.


COMPILE:
========

cd xmlBlaster/demo/c/socket   (see client.c)

Linux:    gcc -Wall -g -D_REENTRANT -I. -o client client.c msgUtil.c socket/*.c -lpthread
          g++ -Wall -g -D_REENTRANT -I. -o client client.c msgUtil.c socket/*.c -lpthread

Windows:  cl /MT /W3 /Wp64 -D_WINDOWS -I. client.c msgUtil.c socket\*.c ws2_32.lib


Now start xmlBlaster:
=====================

   java org.xmlBlaster.Main -dump[socket] true -trace[socket] true -call[socket] true  -call[core] true

and the C client:

   client

The client connects and does some invocations (see the main() in client.c).



How it works:
=============

If you want a client connection (without callback) you need
to include 

   #include <XmlBlasterAccessUnparsed.h>

in your client code, thats it. In this header is a structure which
allows you complete synchronous access to xmlBlaster:

   XmlBlasterException exception;

   XmlBlasterAccessUnparsed *xb = getXmlBlasterAccessUnparsed(argc, argv);
   ...
   response = xb->connect(xb, connectQos, &exception);
   ...
   msgUnitArr = xb->get(xb, "<key oid='__cmd:?freeMem'/>", 0, &exception);
   ...

If you want to install a callback server you need to include the header
CallbackServerUnparsed.h, here is a complete example:

   #include <CallbackServerUnparsed.h>
   int main(int argc, char** argv)
   {
      CallbackServerUnparsed *cb = getCallbackServerUnparsed(argc, argv, myUpdate);
      printf("[main] Created CallbackServerUnparsed instance, creating listener on socket://%s:%d...\n", cb->hostCB, cb->portCB);
      cb->initCallbackServer(cb); // blocks on socket listener

      // This code is reached only on socket EOF
      cb->shutdown(cb);
      printf("[main] Socket listener is shutdown\n");
      freeCallbackServerUnparsed(cb);
      return 0;
   }


Next steps:
===========

o Clean up the code
 - make a lib from it
 - add callback support
   with pthreads on UNIX and
   http://sources.redhat.com/pthreads-win32 on Windows

o Make layers of functionality
 - raw communication
 - adding threading support to allow callbacks in the same process.
 - expat parsing

o Add some demo in xmlBlaster/demo/c

o Wrap it as a C++ protocol plugin to be independend of CORBA and
 use the C++ testsuite for this C implementation 



mr@marcelruff.info 05/2003
