- Primary key generation
  Change id to be generated by DB (seq.nextval @@IDENTITY)
  Having two or more JVM on same database (e.g. a server and many clients) to assure unique primary key:
  SQLServer: 
	create table XX (id bigint identity (1,1) primary key, info varchar(16) default '')
	go
	insert into XX (info) values ('hello')
	select @@IDENTITY as 'Identity'
	go
	select * from XX
	go

  Oracle:
	  CREATE SEQUENCE xmlBlaster_seq
	       INCREMENT BY 1
	       START WITH 1
	       NOMAXVALUE
	       NOCYCLE

	  private static long getNextSeqVal (Connection conn) throws SQLException {
	    Statement stmt = conn.createStatement();
	    ResultSet rs   = stmt.executeQuery("SELECT xmlBlaster_seq.nextval FROM dual");
	    rs.next();
	    long id = rs.getLong(1);
	    rs.close();
	    stmt.close();
	    return id;
	  }

	create table uk_sequence_table ( TABLE_NAME varchar2(100), COUNTER integer );
	ALTER TABLE uk_sequence_table ADD PRIMARY KEY (TABLE_NAME) USING INDEX TABLESPACE TS_SALE_INDEX01;
	CREATE OR REPLACE FUNCTION uk_for_table (tname IN VARCHAR) RETURN INTEGER IS cntr INTEGER; -- declare the return variable BEGIN lock table uk_sequence_table in exclusive mode; update uk_sequence_table set COUNTER = COUNTER + 1 where TABLE_NAME = tname; select COUNTER into cntr from uk_sequence_table where TABLE_NAME = tname; RETURN cntr; END; /
	CREATE OR REPLACE PROCEDURE uk_for_table_proc ( tname IN VARCHAR, lngIdentity OUT INTEGER ) IS BEGIN lock table uk_sequence_table in exclusive mode; update uk_sequence_table set COUNTER = COUNTER + 1 where TABLE_NAME = tname; select COUNTER into lngIdentity from uk_sequence_table where TABLE_NAME = tname; END;
	INSERT INTO uk_sequence_table (TABLE_NAME, COUNTER) VALUES ('<your tablename>', 0); 


- Change xbbytesize to int8 so that sum(xbbytesize) won't fail

- Force old pool: 
  dbPool.class=org.xmlBlaster.contrib.db.DbWaitingPool,\

- Check if CLOB are slow

- Add 'limit'

- Increase connectionPoolSize=5

- XB_ENTRIES lookup in Oracle: check other schames as well

- select * from xbstore; xbnode contains "node" ???

- clientpubisher   | connection   | 2
  How to distinguish one client connecting to two different clusters with same login name
  -> Possibility to force the xbnode

- Finish delegate to recover exceptions for all methods: XbDatabaseAccessorDelegate

- Consistency check is only for old xb_entries: RequestBroker.checkCallbackEntriesConsistency()

- Add Indexes (similar to SQLServer in *Factory.java)

- We need a delegate to recover exceptions: XbDatabaseAccessorDelegate

- Consistency check is only for old xb_entries: RequestBroker.checkCallbackEntriesConsistency()

