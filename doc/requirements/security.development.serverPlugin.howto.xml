<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='security.development.serverPlugin.howto' type='NEW' prio='HIGH' status='CLOSED'>
   <topic>HOWTO: Development of a Server Side Security Plugin</topic>
   <description>
      
   <h1>Introduction</h1>
      <p>
         As mentioned, the xmlBlaster security system is not and cannot be a completely implemented piece of
         software, which refers all aspects of security. The only thing it does, is to support the fundamentals
         as a framework. <br />
         In most cases, security functions require extra jobs (e.g. encryption - decryption) 
         to be done on client side as well as on server side. Thus the framework can be divided into two main
         aspect: Server side and client side.
         But because of the fact, that a developer of an xmlBlaster client program doesn't need to use xmlBlaster
         client helper classes. Security functions cannot be guarenteed for client developers to be transparent.
         Thus a security plugin developer has to implement the server part, but it makes no sense to bind the 
         developer to implement the client plugin, too. Although it is optional, I advice to do it.
      </p>
      <p>
         Anyhow, this part of the xmlBlaster security howto describes only the server part.
      </p>
      <h1>Preparations</h1>
      <p>
         The first and most important step of developing a security plugin is to get the requirements straight.
         Therefore you should be able to answer following questions:
      </p>
      <ul>   
         <li>What is the general goal? What do you want to protect?</li>
         <li>Which kinds of threads do you suppose? </li>
         <li>Which of them do you want to prevent? (Possibly, the benefit won't justify the costs!)</li>         
         <li>What are the inherited security functions? (Authentication, authorization, ...)</li>         
         <li>What are the characteristics of the security functions? (E.g. a more or less strong encryption)</li>
         <li>How do you want to implement these functions? (E.g. authentication via password or fingerprint)</li>
         <li>Do you want to integrate existing services? (Kerberos, passwd-files, ...)</li>
         <li>...</li>
      </ul>
      <p>
         In general, you must know what you want and how to achieve this. If so, there won't be a problem to
         integrate all that into the xmlBlaster. The only thing you have to do, is to implement the following interfaces:
      </p>
        <center><img src="xmlBlaster_sec_classdiag.gif" border="0" /></center>
            <ol>
               <li><pre>org.xmlBlaster.authentication.plugins.I_Manager</pre></li>
               <li><pre>org.xmlBlaster.authentication.plugins.I_Session</pre></li>
               <li><pre>org.xmlBlaster.authentication.plugins.I_Subject</pre></li>
               <li><pre>org.xmlBlaster.authentication.plugins.I_SecurityQos</pre></li>
            </ol>    
<br />
        <h1>What is the intention of the interfaces, methods and values?</h1>    
            <p>  
            <h2><pre>org.xmlBlaster.authentication.plugins.I_Manager</pre></h2>
            The implementation of <code>I_Manager</code> is the central class loaded by the plugin loader. Therefore
            <code>I_Manager</code> extends <code>I_Plugin</code>. First of all, the methods defined in this interface
            have to be implemented to be able to load the plugin via the plugin loader. In a second step the methods of 
            <code>I_Manager</code> must be implemented. Namely:
            </p>
            <ul>
               <li><pre>public I_Session reserveSession(String sessionId) throws XmlBlasterException</pre>
                   This method will be called from xmlBlasted while a user (subject) tries to log on. The only 
                   parameter <code>sessionId</code> is a unique id for each session, generated by the xmlBlaster.
                   The result is a session of an unauthenticated subject. In order to authenticate the subject, 
                   the xmlBlaster will call <code>I_Session.init(String)</code>.</li>
               <li><pre>public void releaseSession(String sessionId, String qos_literal) throws XmlBlasterException</pre>
                   This is the counter part of <code>reserveSession(...)</code>. It's called while a logout e.g.
                   to remove the session from the plugins internal session list (if it has one).
                   The first parameter contains the id of the session. The second parameter
                   is an optional qos literal. The plugin could use it e.g. to proof the authenticity of the
                   source of the logout/disconnect request.</li>
               <li><pre>public I_Session getSessionById(String _id) throws XmlBlasterException</pre>
                   The last method serves a way to determine a sessions security context via a textual session id.
                   It must return the corresponding session, if it exists. Otherwise, it return <code>null</code></li>
            </ul>
            
            <p>
            <h2><pre>org.xmlBlaster.authentication.plugins.I_Session</pre></h2>
            <code>I_Session</code> hides the implementation of session specific methods. Exactly one object
            exists per session. The follow methods have to be implemented:</p>
            <ul>
               <li><pre>public String init(String securityQos) throws XmlBlasterException</pre>
                   <code>init(...)</code> is called as part of the login process. In the first step,
                   the xmlBlaser reserves an <code>I_Session</code>-Object via 
                   <code>I_Manager.reserveSession(String sessionId)</code>. If this happened without an
                   exception, <code>I_Session</code> will be initialized using this method.
                   The implementor may use it e.g. to authenticate subjects, log information to make
                   subjects accountable for actions, etc..
                   The parameter <code>securityQos</code> is part of the login qos, provided by the client.
                   It can be uses for exchange of crypto keys, transmission of information (e.g.
                   user and password) for authemtication ...
                   The result is a qos literal, too. It may be used e.g. to return keys, the session id,
                   etc..</li>
               <li><pre>public String init(I_SecurityQos securityQos) throws XmlBlasterException</pre> 
                   This is basically the same as the last method. Its difference is only the type of the 
                   parameter <code>securityQos</code>. The qos has already been mapped to an object.</li>
               <li><pre>public I_Subject getSubject()</pre>
                    Returns the corresponding subject.</li>
               <li><pre>public I_Manager getManager()</pre>
                   Returns the responsible <code>I_Manager</code>.</li>
               <li><pre>public void changeSecretSessionId(String sessionId) throws XmlBlasterException</pre>
                   Because the current implementation of <code>org.xmlBlaster.authentication.Authenticate#connect(org.xmlBlaster.util.qos.ConnectQos, String)</code>
                   cannot provide a correct session id when an object of <code>I_Session</code> is instantiated,
                   the id must be changed later. Therefore <code>I_Session</code> provides this method.</li>
               <li><pre>public String getSecretSessionId()</pre>
                   Returns the id of this session.</li>
            </ul>
            

            <p>
            <h2><pre>org.xmlBlaster.authentication.plugins.I_MsgSecurityInterceptor</pre></h2>
            <code>I_MsgSecurityInterceptor</code> hides the implementation of message encryption and decryption.
            The follow methods have to be implemented:</p>
            <ul>
               <li><pre>public MsgUnitRaw importMessage(MsgUnitRaw msg, MethodName action) throws XmlBlasterException</pre>
                   <pre>public String importMessage(String xmlMsg) throws XmlBlasterException</pre>
                   <pre>public byte[] importMessage(byte[] content) throws XmlBlasterException</pre>
                   The job of these methods is the import of messages. Therefore all incomming messages and 
                   message components (like qos without key and content) will be routed through one of these methods.
                   In an implementation, they can be used to decrypt the information, verify a signature, log some
                   information, and so on.</li>
               <li><pre>public MsgUnitRaw exportMessage(MsgUnitRaw msg) throws XmlBlasterException</pre>
                   <pre>public String exportMessage(String xmlMsg) throws XmlBlasterException</pre>
                   <pre>public byte[] exportMessage(byte[] content) throws XmlBlasterException</pre>
                   These are the counterparts of of <code>MsgUnitRaw importMessage(MsgUnitRaw msg, MethodName action)</code> and
                   <code>String importMessage(String xmlMsg)</code>. Thus, they are the right location to encrypt,
                   sign, log, etc. outgoing messages.</li>
            </ul>
            

            <p>  
               <h2><pre>org.xmlBlaster.authentication.plugins.I_SecurityQos</pre></h2>
               Implementations of <code>I_SecurityQos</code> are simple wrappers for security related qos information.
               Both ways (XML to object and object to XML) have to be implemented.
               Following methods must be implemented:
               <ul>
                  <li><pre>public void parse(String xml) throws XmlBlasterException</pre>
                      Parses the given XML literal and turns it into an object. Note: The XML literal doesn't represent
                      a complete qos. It covers only the security related part of the qos, which is always enclosed
                      by <code>&lt;securityService type='' version=''>...&lt;/securityService></code>. Example:<br />
                      A typical qos looks like this:
<example lang='xml'>
 <pre>
    &lt;qos>
       ...
       &lt;securityService type='htpasswd' version='1.0'>
          &lt;![CDATA[
             &lt;user>fred&lt;/user>
             &lt;passwd>secret&lt;/passwd>
          ]]\>
       &lt;/securityService>
       ...
    &lt;/qos>
 </pre>
</example>
                      The attributes of <code>&lt;securityService></code> are also mandatory. They are used by the qos-parser
                      to determine the right plugin. 
                  </li>
                  <li>
                     <pre>public void setUserId(String userId)</pre>
                     Used to replace the userId.
                  </li>
                  <li>
                     <pre>public String getUserId()</pre>
                     Has to return a previously set or parsed userId.
               </li>
               <li><pre>public void setCredential(String cred)</pre>
                   This is used to set the credential. E.g. a password, signature, etc.                   
               </li>
               <li><pre>public String getPluginType()</pre>
                   Must return the type of the plugin (e.g. 'htpasswd').                    
               </li>
               <li><pre>public String getPluginVersion()</pre>
                   Must return the plugins version (e.g. '1.0').
               </li>
               <li><pre>public void toXml(String extraOffset)</pre>
                   This is the counterpart of <code>public void parse(String xml) throws XmlBlasterException</code>.
                   So it must serialize the data into an xml-stream. The purpose of the only parameter is to beautify
                   the returned stream by indention.
               </li>
            </ul>
         </p>


            <p>  
               <h2><pre>org.xmlBlaster.authentication.plugins.I_Subject</pre></h2>
               Implementations of <code>I_Subject</code> user related attributes and methods. 
               Following methods have to be implemented:
               <ul>
                  <li><pre>public boolean isAuthorized(String actionKey, String key)</pre>
                      The intention of this method ist to check, if the subject (user) has the permission to perform a specific task.
                      The first parameter describes the kind of the task (i.e. publish, subscribe, get, erase, ... see 
                      <code>org.xmlBlaster.util.def.Constants</code>. Whereas the second parameter describe whereon the task will
                      be performed. Example: <code>isAuthorized("publish", "aMessageKey");</code><br />
                      The example would check if the subject is permitted to 'publish' a message with the key 'aMessageKey'. 
                  </li>
                  <li><pre>public String getName()</pre>
                      getName has to return the subjects name.
                  </li>
              </ul>
           </p>
        <br />
        <h1>How it all fits together - the passwd example</h1>
        <p>
        This chapter shows how it all fits together using probably the simples example. A plugin that logs some information and authenticates
        subjects via a Unix passwd file.
        </p>
        <br />
        <h2>Initialization and connecting</h2>
        <p>
        Considered from the clients point of view, everything begins with establishing a xmlBlaster connection and the succeeding login.
        Therefore, the server requires a loginQos. This contains also security related information embedded in:
        </p>
<example lang='xml'>
 <pre>
 &lt;securityService type='passwd' version='1.0'>
    &lt;![CDATA[
       ...
    ]]\>
 &lt;/securityService>
 </pre>
</example>
<p>
        The server parses the qos end extracts this part including the securityService-tag. In a next step, the xmlBlaster tries to find
        a plugin with the type "passwd" and version "1.0" (<code>PluginManager.getManager(...)</code>) in its local cache respectively in the xmlBlaster.properties and will probably 
        find there the following lines:
</p>
<example lang='properties'>
<pre>
   Security.Server.Plugin[passwd][1.0]=org.xmlBlaster.authentication.plugins.passwd.PasswdManager   
</pre>
</example>
        <center><img src="xmlBlaster_sec_login_seq.gif" border="0" /></center>
<p>
        If so, it will try to instanciate the class. Therefore <code>PasswdManager</code> has to implement the <code>I_Manager</code> interface
        which extends the <code>I_Plugin</code> interface. After creating an object, the objects construct will be call. That permits us i.e.
        to read config. data, open the passwd file and store user name and password as key-value pairs in a Hashtable, etc.. After this has taken place, <code>Autheticate.connect(...)</code> will call <code>PasswdManager.reserveSession(...)</code>.
        It simply creates a new object of PasswdSession and stores it in a Hashtable. It is necessary to store each valid session, because
        <code>getSessionById(...)</code> may be called. Moreover, it permits us to implement some timeout behaviour.    
</p>
<example lang='Java'>
 <pre>
   Hashtable sessions = new Hashtable();

   ...

   public I_Session reserveSession(String sessionId) {
      Session session = new Session(this, sessionId);
      synchronized(sessions) {
         sessions.put(sessionId, session);
      }

      return session;
   }
 </pre>
</example>
        <p>
         <code>Autheticate.connect(...)</code> will subsequently call <code>init(...)</code> on the just created object.
         This is the right place to identify the subject. Thus, it is necessary to get the PasswdSubject object which corresponds
         to the userId. If such an object doesn't exist, we know that the user is known and a "Access Denied" exception needs to be thrown.
         Otherwise the returned object will help us to authenticate the user.
        </p>
        <p>
         But before that takes place, we need a method that serves the PasswdSubject objects. The best place to implement it is the PasswdManager:
        </p>
<example lang='Java'>
 <pre>
   Hashtable allSubjects = new Hashtable();

   ...

   PasswdSubject getSubject(String _userId) {
      String       password;
      PasswdSubject subject;
      
      password = allSubjects.get(_userId);
      if (password==null) { // user is unknown
         subject = null
      }
      else {
         subject = new PasswdSubject(_userId, password); 
         // create new Object and fill it with user and password data 
      }

      return subject;
   }
</pre>
</example>
        <center><img src="xmlBlaster_sec_passwdlogin_seq.gif" border="0" /></center>
        <p>
         Now, it is possible to check the users authenticity from <code>PasswdSession.init(...)</code> with <code>PasswdSubject.authenticate(...)</code>.
        </p>
<example lang='Java'>
 <pre>
   String username;
   String password;
   
   ...
   
   public boolean authenticate(String _passwd) {
      String encryptedPasswd = .... ; // generate unix encrypted passwd

      return (encryptedPasswd == password);
   }
 </pre>
</example>
        <p>
         The <code>PasswdSession.init(...)</code>-method itself:
        </p>   
<example lang='Java'>
 <pre>
   PasswdSubject subject = null;
   PasswdManager     mgr;
   String      sessionId;
   boolean authenticated = false; // successfully authenticated?

   // Constructor 
   public Session(PasswdManager _mgr, String sessionId) {
     mgr = _mgr;
     sessionId = sessionId;
   }

   public String init(String xmlQos_literal) throws 
      XmlBlasterException 
   {
      return init(new SecurityQos(xmlQos_literal));
   }

   public String init(I_SecurityQos securityQos) 
      throws XmlBlasterException 
   {
      authenticated = false;

      // Security function: IDENTIFICATION
      subject = mgr.getSubject(((SecurityQos)securityQos).getCredential()); 
      if (subject==null) 
         throw new XmlBlasterException("Access denied!"); // User unknown
      
      // Security Function: AUTHENTICATION
      authenticated = subject.authenticate(securityQos.getUserId());
      if (!authenticated)
         throw new XmlBlasterException("Access denied!"); // Wrong password

      return null; // we don't support a return qos (e.g. helpful for key-exchange)
   }
 </pre>
</example>
   <p>
     Finally <code>Autheticate.connect(...)</code> calls <code>getSubject()</code> on the just initialized <code>I_Session</code> object,
     before it returns and the user has logged on.
   </p>
   <br />
   <h2>Publishing a message</h2>
   <p>
    Okay, so far so good. The user successfully connected to the xmlBlaster. But what happens if the user wants i.e. to publish a message?
   </p>
   <p>
   <center><img src="xmlBlaster_sec_authorization_seq.gif" border="0" /></center>
   </p>
   <p>
   After the user has called the servers publish method, it imports (e.g. decrypts, unseals, logs, ...) the message and checks the permission. 
   It does this by calling the local method <code>private MsgUnit checkMessage(SessionInfo sessionInfo, MsgUnit msgUnit, String action) throws XmlBlasterException</code>,
   which fetches the security session context (the responsible I_Session instance) from the xmlBlaster session, which will be determined by 
   the session id.<br />
   Now, the <code>I_Session</code> instance can be used to log, encrypt or unseal the message. In our implementation (PasswdSession) we don't
   support these features and return the message as it was given.<br />
   Additionally, <code>I_Session</code> will be used to get the Subject via <code>getSubject()</code>. This is necessary to check the permissions
   in a final step. Therefore, <code>I_Subject.isAuthoriued(...)</code> will be call. But because our driver doesn't support this, too, 
   <code>I_Subject.isAuthoriued(...)</code> returns <code>true</code> in each case.<br />
   If these actions took place without problems, the xmlBlaster will continue with publishing the message. Otherwise it exits with an <code>XmlBlasterException</code>.
   </p>
   <br />
   <p>
   Other action like subscribtions, erasing messages, and so on follow the same pattern.
   </p>
   <br />
   <h1>Conclusion</h1>
   You've got a first impression what a developer of a security plugin has to do. The next step (if necessary) should be the examination
   of one of the existing security plugins.
</description>
<example>
</example>
<see type="REQ">security.introduction</see>
<see type="REQ">security.htpasswd</see>
<see type="REQ">security.ldap</see>
<see type="REQ" label="SOCKET based SSL protection">protocol.socket</see>
<see type="API">org.xmlBlaster.authentication.plugins.I_Manager</see>
<see type="API">org.xmlBlaster.authentication.plugins.I_Session</see>
<see type="API">org.xmlBlaster.authentication.plugins.I_Subject</see>
<see type="API">org.xmlBlaster.authentication.plugins.I_SecurityQos</see>
<see type="API">org.xmlBlaster.authentication.plugins.I_MsgSecurityInterceptor</see>
</requirement>
