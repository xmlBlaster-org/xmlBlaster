<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='protocol.socket' type='NEW' prio='HIGH' status="CLOSED">
   <topic>XmlBlaster supports a bidirectional native communication protocol using exactly one socket connection</topic>
   <description>
      <p>
      RPC (remote procedure call) based frameworks like CORBA, RMI and XmlRpc require the client
      to set up a callback server for asynchronous callbacks. This causes problems if the client
      is behind a firewall or if the client may not establish a listen socket.
      Reusing a socket for callbacks solves this problem.
      </p>
      <p>
      Further this protocol can be used for simple access from other programming languages like <i>C</i>.
      </p>
      <h2>
      Protocol specification
      </h2>
   <p>
   Design decisions:
   </p>
   <ul>
     <li>Uses no bit settings to allow simple access with any programming language</li>
     <li>To avoid bigendian/littleendian problems no netlong etc. are used</li>
     <li>All numbers are delivered as strings.</li>
     <li>The fixed size header fields have even boundaries</li>
     <li>Compact format for good performance</li>
   </ul>
   <br />
   <p>
   This specifies the raw data format, '*' is used to symbolize null terminated strings:
   </p>
   <pre>
msgLen[10] flag[6] requestId methodName secretSessionId lenUnzipped userData checkSum[10]
+---------+-------+------ -*----------*----------------*-----------*--------+-----------+
   </pre>
   <p>
   Description:
   </p>
   <table width="100%" border="1">
      <tr>
         <th>Field</th>
         <th>Description</th>
         <th>Size [bytes]</th>
      </tr>
      <tr>
         <td>msgLen</td>
         <td>The number of bytes of the message, including itself, the header, the data (and the checksum if appended)</td>
         <td>10</td>
      </tr>
      <tr>
         <td>flag</td>
         <td>The flag defaults to zero (all bits are '\0', only version is set to one '1'=49 and 'I'=73 for invoke), possible settings of each byte are:
            <ol>
               <li>65 (typically 'A') Adler32 checksum is appended (see java.util.zip) [Currently not supported]</li>
               <li>90 (typically 'Z') The userData is compressed with gzip (see jzlib and zlib). Currently there is support to compress the whole socket stream - in such case this flag makes no sense and is not set</li>
               <li>Type of message<ul><li>73 (typically 'I') for invoke request</li><li>82 (typically 'R') for return value</li><li>69 (typically 'E') for exception</li></ul></li>
               <li>null ('\0'), Reserved</li>
               <li>null ('\0'), Reserved</li>
               <li>49 (typically '1') Version byte for this protocol</li>
            </ol>
         </td>
         <td>6</td>
      </tr>
      <tr>
         <td>requestId</td>
         <td>An identifier of this request (unique in client scope), the return message will contain this ID.
            The server bounces this requestId back, it does not use it. This is useful
            for the client to find out which response belongs to which request.<br />
            For callback calls like <tt>update()</tt> or <tt>ping()</tt> the client must return this
            id so xmlBlaster knows to which invocation the response belongs.</td>
         <td>null terminated</td>
      </tr>
      <tr>
         <td>methodName</td>
         <td>The method to invoke, like "publish", "subscribe", "update"</td>
         <td>null terminated</td>
      </tr>
      <tr>
         <td>secretSessionId</td>
         <td>The secret session ID for authentication, it is empty on first connect
         and generated by xmlBlaster for the connect return QoS. All other requests
         then use this secret session ID</td>
         <td>null terminated</td>
      </tr>
      <tr>
         <td>lenUnzipped</td>
         <td>The length of the uncompressed user data, allows for example in C to simple allocate enough memory.
         This field has only a value if the flag is set to 'Z' (compressed), otherwise it is just the terminating '\0'.</td>
         <td>null terminated</td>
      </tr>
      <tr>
         <td>userData</td>
         <td>The arguments of the invoked message (see below)</td>
         <td>any (0 is allowed as well)</td>
      </tr>
      <tr>
         <td>checkSum</td>
         <td>An optional checksum if the flag field is set</td>
         <td>10</td>
      </tr>
   </table>
   <br />
   <p>
   The userData has the following typical layout.
   </p>
   <pre>
     qos      key    len   content
   +-----*---------*-----*----------+
   </pre>
   <p>
   len (written as a string with a terminating 0) is the length of the content.<br />
   This may be repeated multiple times if an array of MsgUnits is sent.<br />
   If for example only a qos is transmitted,
   the key may optionally consist only of the terminating null byte
   and the content len is set to 0 with a terminating null byte.
   </p>
   <p>
   The following table lists all allowed methods, with their arguments, return values and exceptions.<br />
   Note that all data types are of type string and are terminated with a '\0'.<br />
   Only the content is of type 'binary' which length can be calculated by the
   len field. Binary data is not zero terminated.
   </p>
   <table width="100%" border="1">
      <tr>
         <th>Method</th>
         <th>Arguments</th>
         <th>Return value</th>
         <th>Excep<br />tion</th>
         <th>Comment</th>
      </tr>
      <tr>
         <td>connect</td>
         <td>QoS{string}</td>
         <td>QoS{string}</td>
         <td><img src="ok.gif" border="0" alt="yes" /></td>
         <td>The secretSessionId field is an empty string (just the '\0'), the server
             generates and returns it.</td>
      </tr>
      <tr>
         <td>disconnect</td>
         <td>QoS{string}</td>
         <td>QoS{string}</td>
         <td><img src="ok.gif" border="0" alt="yes" /></td>
         <td>The server sends the response (ACK) immediately from the SOCKET layer.
             It can't send it later because the socket is shutdown during server side disconnect</td>
      </tr>
      <tr>
         <td>ping</td>
         <td>QoS{string}</td>
         <td>QoS{string}</td>
         <td><img src="no.gif" border="0" alt="no" /></td>
         <td>The QoS can be an empty string ""</td>
      </tr>
      <tr>
         <td>{exception}</td>
         <td>errorCode{string}, message{string}, byteDump of exception</td>
         <td>-</td>
         <td><img src="no.gif" border="0" alt="no" /></td>
         <td>Exception return messages are named similar to the invoked method but are marked with an 'E' flag.<br />
         See XmlBlasterException.java toByteArr() for the syntax of the binary message content.
         </td>
      </tr>
      <tr>
         <td>update</td>
         <td>[QoS{string}, key{string}, content{binary}]*</td>
         <td>[QoS{string}]*</td>
         <td><img src="ok.gif" border="0" alt="yes" /></td>
         <td>This is a callback message to the client, the message unit (QoS, key, content) may be specified multiple times. 
             Every message unit has a corresponding return QoS.
         </td>
      </tr>
      <tr>
         <td>updateOneway</td>
         <td>[QoS{string}, key{string}, content{binary}]*</td>
         <td>-</td>
         <td><img src="no.gif" border="0" alt="no" /></td>
         <td>This is a callback message to the client, the message unit (QoS, key, content) may be specified multiple times. 
             There is no return value and no exception which can be thrown for maximum performance.<br />
             This call can be configured to use UDP instead of TCP, note however that UDP has a limited datagram size.
         </td>
      </tr>
      <tr>
         <td>publish</td>
         <td>[QoS{string}, key{string}, content{binary}]*</td>
         <td>[QoS{string}]*</td>
         <td><img src="ok.gif" border="0" alt="yes" /></td>
         <td>The message unit [QoS, key, content] may be specified multiple times.
             Every message unit has a corresponding return QoS.
             This publish covers the CORBA publish() and the CORBA publishArr().
         </td>
      </tr>
      <tr>
         <td>publishOneway</td>
         <td>[QoS{string}, key{string}, content{binary}]*</td>
         <td>-</td>
         <td><img src="no.gif" border="0" alt="no" /></td>
         <td>The message unit [QoS, key, content] may be specified multiple times.
             There is no return value and no exception which can be thrown for maximum performance.<br />
             This call can be configured to use UDP instead of TCP, note however that UDP has a limited datagram size.
         </td>
      </tr>
      <tr>
         <td>get</td>
         <td>QoS{string}, key{string}</td>
         <td>[QoS{string}, key{string}, content{binary}]*</td>
         <td><img src="ok.gif" border="0" alt="yes" /></td>
         <td>The returned QoS, key, content may be zero to multiple items</td>
      </tr>
      <tr>
         <td>subscribe</td>
         <td>QoS{string}, key{string}</td>
         <td>QoS string</td>
         <td><img src="ok.gif" border="0" alt="yes" /></td>
         <td>subscribe for messages</td>
      </tr>
      <tr>
         <td>unSubscribe</td>
         <td>QoS{string}, key{string}</td>
         <td>[QoS{string}]*</td>
         <td><img src="ok.gif" border="0" alt="yes" /></td>
         <td>cancel subscriptions</td>
      </tr>
      <tr>
         <td>erase</td>
         <td>QoS{string}, key{string}</td>
         <td>[QoS{string}]*</td>
         <td><img src="ok.gif" border="0" alt="yes" /></td>
         <td>erase messages</td>
      </tr>
   </table>
   <br />
      <h2>NOTE:</h2>
      <p>
      The raw SOCKET address transferred in the connect QoS markup is of the form
      </p>
      <pre>
socket://host:port
      </pre>
      <p>
      for example:
      <pre>
socket://127.168.1.2:7607
      </pre>
      </p>
   </description>
   <example lang="any">
      <![CDATA[
      
Example of a publish() invocation with qos/key/content

   "        83**I**17711*publish*oxf6hZs**<qos></qos>*<key oid='hello'/>*11*Hello world"

Example of a get() invocation with qos/key

   "        70**I**17711*get*oxf6hZs**<qos></qos>*<key oid='ooo'></key>*0*"

Example of a publish() return with qos

   "        48**R**17711*publish*oxf6hZs**<qos/>**0*"

Example of an empty get()

   "        34**I**17711*get*oxf6hZs**"

Example of a ping() (with an empty qos):

   "        25**I**11*ping***"

Example of an XmlBlasterException as a response on a publish() (a content is not shown):

   "        84**E**17711*publish*oxf6hZs**QueueOverflow*The destination queue is full*0*"

Example of a qos/key/content return value of a get()

   "        81**R**17711*get***<qos></qos>*<key oid='hello'/>*20*Hello world response"

Example of a QoS return value of erase()

   "        60**R**17711*erase***<qos><state id='OK'/></qos>**0*"

Example of publish() with two qos/key/content (split to two lines)

   "       100**I**17711*publish*oxf6hZs**<qos/>*<key oid='x1'/>*6*Hello1<qos/>
    *<key oid='x2'/>*6*Hello2"


The '*' is used as a symbol for a '\0' character (all zero bits) which terminates strings.

The content of a message, here for example 'Hello world' is binary data and has no '\0',
it is determined by len.

The '"' is just to show the boundary, '"' is not part of the message.
      ]]>

      <p>You can switch on dumping of such SOCKET messages with following command line argument:
      </p>
      <pre>
java -Dcom.sun.management.jmxremote org.xmlBlaster.Main -logging/org.xmlBlaster.util.protocol.RequestReplyExecutor FINEST 
      </pre>
   </example>

   <example lang="Java" type="HTML">
      <h2>
      Java command line examples
      </h2>
      <p>
      You can switch on nice debugging output with these options:
      </p>
      <pre>
java -jar lib/xmlBlaster.jar -dump[socket] true -trace[socket] true
      </pre>
      <br />
      <p>
      Here we start the xmlBlaster server and it will offer its SOCKET service on host <i>myHost.com</i> and on port <i>7766</i>:
      </p>
      <pre>
java -jar lib/xmlBlaster.jar -plugin/socket/hostname myHost.com
                             -plugin/socket/port 7766
      </pre>
      <p>
      This client tries to find an xmlBlaster server instance at host <i>myHost.com</i> and on port <i>7766</i>:
      </p>
      <pre>
java HelloWorld3 -protocol SOCKET -dispatch/connection/plugin/socket/hostname myHost.com
                                  -dispatch/connection/plugin/socket/port 7766
      </pre>

      <br />
      <p>
      Here we do the same hard coded in Java:
      </p>
      <pre>
...

String[] args = { "-protocol", "SOCKET",
                "-dispatch/connection/plugin/socket/hostname", "myHost.com",
                "-dispatch/connection/plugin/socket/port", "7766",
                "-dispatch/connection/plugin/socket/localHostname", "myHost.com",
                "-dispatch/connection/plugin/socket/localPort", "8888" };
glob.init(args);

ConnectQos qos = new ConnectQos(glob);

...
      </pre>
   </example>

   <example lang="Java" type="HTML">
      <h2 id="SSL1">
      Using SSL communication
      </h2>
      <p>
      To establish a SSL connection you need to set some configuration properties on command line
      or in xmlBlaster.properties.
      This works out of the box for JDK 1.4 and above. For JDK 1.3 you need
      to install the SSL support separately.
      SSL is available with IBM JDK 1.4 as well, using for example a client running with SUN JDK 1.4 or 1.5
      to communicate with a xmlBlaster server running with IBM JDK 1.4
      (even if compiled with SUN JDK 1.3) works fine.
      </p>
      <p>
      The first step is to generate a certificate with the <tt>keytool</tt> program that comes with the SDK.
      Issue the keytool command with the -genkey option to generate a keypair, the -keystore option
      to specify the key store file, and the -keyalg options to specify the encryption algorithm, read
      the <a href="http://java.sun.com/developer/JDCTechTips/2004/tt0914.html#2" target="others">SSL tutorial</a> and the
      <a href="http://java.sun.com/j2se/1.4.2/docs/guide/security/jsse/JSSERefGuide.html" target="SSL">SSL reference guide</a>
      for more details:
      </p>
      <pre>
keytool -genkey -dname "cn=xmlBlaster, ou=server, o=xmlBlaster, c=org" -alias xmlBlaster
        --keypass testtest -keystore testStore -storepass testtest -keyalg RSA
      </pre>
      <p>
      Now you are ready to start the xmlBlaster server with enabled SSL (all in one line):
      </p>
      <pre>
java -jar lib/xmlBlaster.jar -plugin/socket/SSL true -plugin/socket/keyStore testStore
                                                     -plugin/socket/keyStorePassword testtest
      </pre>
      <p>
      and finally we start a client to test it:
      </p>
      <pre>
java HelloWorld3 -protocol SOCKET -plugin/socket/SSL true -plugin/socket/trustStore testStore
      </pre>
      <p>
      To check the encryption dump the TCP/IP packages for example with tcpdump:
      </p>
      <pre>
tcpdump -i lo -A -vvv dst port 7607
      </pre>
      <p>
      If you encounter problems you can switch on SSL debugging with
      </p>
      <pre>
java -Djavax.net.debug=all ...
      </pre>
      <p>
      These are the benefits of the above connection:
      </p>
      <ul>
          <li>Integrity Protection. SSL protects against modification of messages by an active wiretapper.</li>
          <li>Authentication. Here xmlBlaster is authenticated, the client knows to which xmlBlaster it talks,
              but xmlBlaster does not assure on this SSL layer who the client is.</li>
          <li>Confidentiality (Privacy Protection). In most modes, SSL encrypts data being sent between client and server. This protects the confidentiality of data, so that passive wiretappers won't see sensitive data such as financial information or personal information of many kinds.</li>
      </ul>
   </example>

   <example lang="Java" type="HTML">
      <h2 id="SSL2">
      Using SSL communication with additional client authentication
      </h2>
      <p>
      In the section before we have explained how to establish a SSL connection between
      a client and xmlBlaster, in that setup xmlBlaster did not authenticate the clients on SSL layer.
      Let's add additionally client authentication.
      The following steps create a client private key and than exchange the clients and servers public
      key so that both sides know the other side.
      </p>
      <p>
      Create a private key for client <i>joe</i>:
      </p>
      <tt>
keytool -genkey -dname "cn=joe, ou=client, o=xmlBlaster, c=org" -alias joe
        --keypass testtest -keystore testStore.joe -storepass testtest -keyalg RSA
      </tt>
      <p>
      Export joe's certificate:
      </p>
      <tt>
keytool -alias joe -export -keystore testStore.joe -storepass testtest -rfc -file joeTrustStore.Cert
      </tt>
      <p>
      and import it to the servers trust store named <tt>testStore</tt>:
      </p>
      <tt>
keytool -import -alias joe -file joeTrustStore.Cert -keystore testStore -storepass testtest
      </tt>
      <p>
      Create a certificate of the xmlBlaster server (the servers private key is in <tt>testStore</tt> which 
      was created in the example before):
      </p>
      <tt>
keytool -alias xmlBlaster -export -keystore testStore -storepass testtest -rfc -file xmlBlasterTrustStore.Cert
      </tt>
      <p>
      and import it to joe's trust store:
      </p>
      <tt>
keytool -import -alias xmlBlaster -file xmlBlasterTrustStore.Cert -keystore testStore.joe -storepass testtest
      </tt>
      <p>
      On problems look into the key store file and verify all is correct:
      </p>
      <tt>
keytool -list -v  -storepass testtest -keystore testStore.joe<br />
keytool -list -v  -storepass testtest -keystore testStore
keytool -printcert -file xmlBlasterTrustStore.Cert
      </tt>

      <p>
      Start the server:
      </p>
      <tt>
java -jar lib/xmlBlaster.jar -plugin/socket/SSL true -plugin/socket/keyStore testStore -plugin/socket/keyStorePassword testtest -plugin/socket/trustStore testStore -plugin/socket/trustStorePassword testtest -plugin/socket/needClientAuth true
      </tt>
      <p>
      and a client to test it:
      </p>
      <tt>
java HelloWorld3 -protocol SOCKET -plugin/socket/SSL true -plugin/socket/keyStore testStore.joe -plugin/socket/keyStorePassword testtest  -plugin/socket/findStoreInXmlBlasterSearchPath true
      </tt>
      <p>
      These are the benefits of the above connection:
      </p>
      <ul>
          <li>Integrity Protection. SSL protects against modification of messages by an active wiretapper.</li>
          <li>Authentication. <b>Here SSL provides peer authentication. The xmlBlaster server is authenticated, and clients need to authenticate themselves.</b></li>
          <li>Confidentiality (Privacy Protection). In most modes, SSL encrypts data being sent between client and server. This protects the confidentiality of data, so that passive wiretappers won't see sensitive data such as financial information or personal information of many kinds.</li>
      </ul>
      <p>
      Note: With the setting <tt>-plugin/socket/findStoreInXmlBlasterSearchPath true</tt> it is
      for example possible to put the <tt>testStore.joe</tt> in the xmlBlaster.jar file and
      it is found over the CLASSPATH.
      </p>
      <p>
      Note: To simplify the server setup you should add all server settings to
      the <tt>xmlBlasterPlugins.xml</tt> file as described in the next example.
      </p>
   </example>

   <example lang="Java" type="HTML">
      <h2 id="SSL">
      Configuring SSL <b>and</b> normal SOCKET communication
      </h2>
      <p>
      If you want to establish a SSL SOCKET server besides a plain text SOCKET server
      you need to register two SOCKET protocol drivers each listening on a different port.
      Here is an example of such entries in <tt>xmlBlasterPlugins.xml</tt>:
      </p>
      <pre>
&lt;plugin id='SOCKET' className='org.xmlBlaster.protocol.socket.SocketDriver'>
   &lt;action do='LOAD' onStartupRunlevel='3' sequence='2' 
           onFail='resource.configuration.pluginFailed'/>
   &lt;action do='STOP' onShutdownRunlevel='2' sequence='5'/>   
&lt;/plugin>

&lt;plugin id='socket_ssl' className='org.xmlBlaster.protocol.socket.SocketDriver'>
   &lt;action do='LOAD' onStartupRunlevel='3' sequence='2' 
           onFail='resource.configuration.pluginFailed'/>
   &lt;action do='STOP' onShutdownRunlevel='2' sequence='5'/>   
   &lt;attribute id='SSL'>true&lt;/attribute>
   &lt;attribute id='trustStore'>testStore&lt;/attribute>
   &lt;attribute id='trustStorePassword'>testtest&lt;/attribute>
   &lt;attribute id='keyStore'>testStore&lt;/attribute>
   &lt;attribute id='keyStorePassword'>testtest&lt;/attribute>
   &lt;attribute id='needClientAuth'>false&lt;/attribute>
   &lt;attribute id='port'>7609&lt;/attribute>
   &lt;attribute id='startUdpListener'>false&lt;/attribute>
&lt;/plugin>
      </pre>
      <p>
      Now the plain SOCKET is listening on default port 7607 and the SSL SOCKET
      listens on port 7609. The 'trustStore' settings are need only when you set up
      clustering with SSL SOCKET cluster internal communication -
      in this case the xmlBlaster server is a client to another xmlBlaster cluster node
      and needs the imported certificate of the remote node in 'testStore'.
      <br />
      Additionally we register the <i>socket_ssl</i> plugins in <tt>xmlBlaster.properties</tt>:
      </p>
      <pre>
# Server side:
CbProtocolPlugin[socket_ssl][1.0]=\
       org.xmlBlaster.protocol.socket.CallbackSocketDriver,SSL=true

# Client side:
ClientProtocolPlugin[socket_ssl][1.0]=\
       org.xmlBlaster.client.protocol.socket.SocketConnection,SSL=true

# Client side:
ClientCbServerProtocolPlugin[socket_ssl][1.0]=\
       org.xmlBlaster.client.protocol.socket.SocketCallbackImpl,SSL=true
      </pre>
      <p>
      Starting the server is simple as all configuration is done in the above
      <tt>xmlBlasterPlugins.xml</tt> file (please read the previous example on
      how to initially generate a keystore):
      </p>
      <pre>
java -jar lib/xmlBlaster.jar
      </pre>
      <p>
      Here we start a client using the default plain text SOCKET connection:
      </p>
      <pre>
java HelloWorld3 -protocol SOCKET
      </pre>
      <p>
      and here we start another client using the secure SSL SOCKET connection:
      </p>
      <pre>
java HelloWorld3 -protocol socket_ssl -plugin/socket_ssl/port 7609 -plugin/socket_ssl/SSL true
                 -plugin/socket_ssl/trustStore testStore
      </pre>
      <p>
      The client side xmlBlaster.properties entries 'socket_ssl' are in fact optional, this would work as well:
      <i>java HelloWorld3 -protocol SOCKET -plugin/socket/port 7609 -plugin/socket/SSL true -plugin/socket/trustStore testStore</i>
      </p>
      <h2>Notes</h2>
      <ul>
      <li>An xmlBlaster server instance can have multiple different SSL SOCKET listeners established,
          all of them reuse the same keystore. You can't use more than one keystore in the same JVM,
          the first loaded keystore is used even if you specifiy another keystore before
          creating the second socket listener.
      </li>
      <li>The above examples clients used the server side 'keystore' file which is a bad idea
          as this file contains besides the certificate the servers private key. To avoid copying 
          the server private key to the clients host you can generate a certificate file which only
          contains the public certificate:<br />
          <p>Export the certificate</p>
          <p>
          <tt>keytool -alias xmlBlaster -export -keystore testStore -rfc -file xmlBlasterTrustStore.Cert</tt>
          </p>
          <p>Create a 'xmlBlaster.truststore' file to be used by clients</p>
          <p>
          <tt>keytool -import -alias xmlBlasterClient -file xmlBlasterTrustStore.Cert -keystore xmlBlasterClient.truststore</tt>
          </p>
          <p>
          and start a demo client:
          </p>
          <p>
          <tt>java HelloWorld3 -protocol SOCKET -plugin/socket/SSL true -plugin/socket/trustStore xmlBlasterClient.truststore -plugin/socket/port 7609</tt>
          </p>
      </li>
      </ul>
   </example>

   <example lang="Java" type="HTML">
      <h2 id="compress">
      Configuring compression
      </h2>
      <p>
      The xmlBlaster SOCKET protocol supports compression with zlib and jzlib.
      Compression support is available for C, C++ and Java clients directly and for
      ActiveX (C#, VisualBasic .net) and Javascript clients via the Java bridge.
      You can switch on two compression modes with the property <i>plugin/socket/compress/type</i>.
      If the server side socket plugin has the option <i>zlib:stream</i> enabled (see <tt>xmlBlasterPlugins.xml</tt>)
      it won't accept uncompressed clients. If you have both types of clients you need
      to register two SOCKET protocol driver in <tt>xmlBlasterPlugins.xml</tt>.
      </p>
      <p>Note that the <i>zlib</i> setting compresses block wise and violates the
      described SOCKET protocol format, it adds a prefix to the message format.
      A first byte at the beginning, the <code>compressionFlag</code>, where '1' is zlib compressed and '0' is uncompressed.
      This is followed by 4 bytes which contain the length of the uncompressed message.
      If <code>compressionFlag==1</code>, there are another 4 bytes which contain the compressed length.
      See <code>ZBlockOutputStream.java:86</code> for more details.
      </p>
      <p>
      For a simple usage in this test we set following parameters in <tt>xmlBlaster.properties</tt>
      </p>
      <pre>
protocol=SOCKET

# No compression
#plugin/socket/compress/type=

# Compress each message separately (available only for Java clients)
#plugin/socket/compress/type=zlib

# Compress in streaming mode (the preferred way, C, C++, Java ... clients)
plugin/socket/compress/type=zlib:stream
      </pre>
      <p>
      We start now a server and a client instance, the client publishes
      10 messages with identical content consisting of one thousand 'X' characters:
      </p>
      <pre>
java org.xmlBlaster.Main

java javaclients.HelloWorldPublish -numPublish 10 -contentSize 1000
      </pre>
      <p>
      If we now restart the client and server for each compression mode and
      add a socket port forwarder which dumps the transferred bytes we get this result:
      </p>
      <table border="1">
         <tr><th>Compression mode</th><th>Message No</th><th>Size of published message [bytes]</th><th>Size of PublishReturnQos (ACK)</th></tr>
         <tr><td rowspan="3">no compression</td><td>1</td><td>1505</td><td>196</td></tr>
         <tr><td>2</td><td>1356</td><td>196</td></tr>
         <tr><td>3</td><td>1356</td><td>196</td></tr>
         
         <tr><td rowspan="5">zlib</td><td>1</td><td>347</td><td>163</td></tr>
         <tr><td>2</td><td>276</td><td>172</td></tr>
         <tr><td>3</td><td>275</td><td>164</td></tr>
         <tr><td>4</td><td>276</td><td>163</td></tr>
         <tr><td>5</td><td>275</td><td>163</td></tr>

         <tr><td rowspan="5">zlib:stream</td><td>1</td><td>276</td><td>76</td></tr>
         <tr><td>2</td><td>28</td><td>17</td></tr>
         <tr><td>3</td><td>21</td><td>17</td></tr>
         <tr><td>4</td><td>22</td><td>17</td></tr>
         <tr><td>5</td><td>22</td><td>16</td></tr>

      </table>
      <p>
      For <i>no compression</i> you can see that the first message overhead is 505 bytes (1505 bytes - 1000 payload)
      because we have delivered the topic QoS on first publish. It than reduces to constantly 356 bytes
      for each published message. The payload (your message content) is 1000 bytes.
      The 356 bytes are mostly due to the used publish QoS settings.
      </p>
      <p>
      Compressing each message as a unit with <i>zlib</i> reduces the message size to 276 bytes.
      The compression header adds overhead for each message.
      </p>
      <p>
      Compressing messages with mode <i>zlib:stream</i> reduces the
      transferred size drastically to 22 bytes per message. The compression
      header is not transferred again.
      </p>
      <b>Note:</b><p>This result is a very optimistic case as the message content consisted
      of one thousand 'X' characters. In your real day messages the compression
      rate will be less and depends on your payload.
      </p> 

      <h2>Compression of SSL connections</h2>
      <p>contentSize=1000</p>
      <table border="1">
         <tr><th>Compression mode</th><th>Message No</th><th>Size of published message [bytes]</th><th>Size of PublishReturnQos (ACK)</th></tr>
         <tr><td rowspan="3">no compression</td><td>1</td><td>1526</td><td>217</td></tr>
         <tr>                                   <td>2</td><td>1377</td><td>217</td></tr>
         <tr>                                   <td>3</td><td>1377</td><td>217</td></tr>
         
         <tr><td rowspan="4">zlib:stream</td><td>1</td><td>294</td><td>96</td></tr>
         <tr><td>2</td><td>49</td><td>38</td></tr>
         <tr><td>3</td><td>43</td><td>37</td></tr>
         <tr><td>4</td><td>43</td><td>38</td></tr>
      </table>

      <p>contentSize=10000</p>
      <table border="1">
         <tr><th>Compression mode</th><th>Message No</th><th>Size of published message [bytes]</th><th>Size of PublishReturnQos (ACK)</th></tr>
         <tr><td rowspan="3">no compression</td><td>1</td><td>10527</td><td>217</td></tr>
         <tr><td>2</td><td>10378</td><td>217</td></tr>
         <tr><td>3</td><td>10378</td><td>217</td></tr>
         
         <tr><td rowspan="5">zlib:stream</td><td>1</td><td>321</td><td>97</td></tr>
         <tr><td>2</td><td>69</td><td>38</td></tr>
         <tr><td>3</td><td>60</td><td>36</td></tr>
         <tr><td>4</td><td>59</td><td>37</td></tr>
         <tr><td>5</td><td>60</td><td>37</td></tr>
      </table>

      <p>Again the results for compression of SSL messages are very promising.</p>

      <h2>Try a C (or C++) client</h2>
      <p>Download <tt>zlib</tt> at http://www.gzip.org/zlib/ and
      edit <tt>build.properties</tt> to set the zlib pathes, finally compile it
      with '<tt>build c</tt>'. Now you are ready to try:
      </p>
<pre>
  HelloWorld3 -plugin/socket/compress/type zlib:stream -plugin/socket/port 7607
</pre>
      <p>Compile the C++ examples with '<tt>build cpp</tt>' and try:
      </p>
<pre>
  PublishDemo -protocol SOCKET -plugin/socket/compress/type zlib:stream 
              -plugin/socket/port 7607 -numPublish 10 -contentSize 10000
</pre>
   </example>


   <example lang="Java" type="HTML">
      <a name="script"/>
      <p class="celltitel">Send xmlBlaster scripts over the socket</p>
      <p>
      It is possible to send other formats over the socket connection.
      The data format described in this requirement is coded in the XbfParser.java class.
      You can however choose to use the XmlScriptParser.java markup to be send (or any other format which may you code yourself). See
      the requirement
      <a href="http://www.xmlblaster.org/xmlBlaster/doc/requirements/client.script.html" target="others">client.script</a>
      how this markup looks like. It is for example used as the default in the
      <a href="http://www.xmlblaster.org/xmlBlaster/doc/requirements/protocol.email.html" target="others">EMAIL protocol plugin</a>.
      </p>
      <p>Here is an example how to switch to scripting markup send over the socket:
      </p>
<pre class="BORDER">
#xmlBlaster.properties (server side)

CbProtocolPlugin[socket_script][1.0]=org.xmlBlaster.protocol.socket.CallbackSocketDriver,\
                             compress/type=,\
                             isNullTerminated=true,\
                             parserClass=org.xmlBlaster.util.xbformat.XmlScriptParser

#xmlBlasterPlugins.xml

&lt;plugin create='true' id='socket_script' className='org.xmlBlaster.protocol.socket.SocketDriver'>
   &lt;action do='LOAD' onStartupRunlevel='4' sequence='20'
            onFail='resource.configuration.pluginFailed'/>
   &lt;action do='STOP' onShutdownRunlevel='3' sequence='50'/>
   &lt;attribute id='compress/type'>&lt;/attribute>
   &lt;attribute id='isNullTerminated'>true&lt;/attribute>
   &lt;attribute id='parserClass'>org.xmlBlaster.util.xbformat.XmlScriptParser&lt;/attribute>
&lt;/plugin>
</pre>

   <p>and on client side:</p>

<pre class="BORDER">
#xmlBlaster.properties (client side)

ClientProtocolPlugin[socket_script][1.0]=org.xmlBlaster.client.protocol.socket.SocketConnection,\
                             compress/type=,\
                             isNullTerminated=true,\
                             parserClass=org.xmlBlaster.util.xbformat.XmlScriptParser


ClientCbServerProtocolPlugin[socket_script][1.0]=org.xmlBlaster.client.protocol.socket.SocketCallbackImpl,\
                             compress/type=,\
                             isNullTerminated=true,\
                             parserClass=org.xmlBlaster.util.xbformat.XmlScriptParser

</pre>

   <p>Please note that you have to pass the <code>parserClass</code> (the same used for EMAIL)
    and additionally the <code>isNullTerminated=true</code> configuration.
    </p>
    <p>To send the script compressed over the wire please use the <code>compress/type=zlib:stream</code>
    setting.</p>
    <p />
    <p>You can switch on dumping of the send and received messages with the following logging configuration
    used on command line:
    </p>
<pre class="BORDER">
-logging/org.xmlBlaster.util.xbformat.XmlScriptParser FINEST
-logging/org.xmlBlaster.util.protocol.socket.SocketExecutor FINEST
</pre>

    <p>which results in a typical logging output like:</p>
<pre class="BORDER">
02.07.2006 22:58:45 FINEST  10-main SocketExecutor sendMessage: Sending TCP data 
[&lt;?xml version='1.0' encoding='UTF-8'?>

&lt;publish sessionId='sessionId:127.0.0.2-null-1151873723867' requestId='name:115187001' type='I'>

 &lt;qos>
  &lt;subscribable/>
  &lt;expiration lifeTime='-1' forceDestroy='false'/>
  &lt;persistent/>
  &lt;forceUpdate/>
  &lt;isPublish/>
 &lt;/qos>

 &lt;key oid='Woodlogging' contentMime='text/xml' contentMimeExtended='1.0' domain='greenwood'>
  &lt;org.xmlBlaster>&lt;demo-2/>&lt;/org.xmlBlaster>
 &lt;/key>
  &lt;content type='String'>Hi-2&lt;/content>
&lt;/publish>
]
02.07.2006 22:58:45  FINE   10-main SocketExecutor sendMessage: TCP data is send
02.07.2006 22:58:45 FINEST  11-XmlBlaster.SOCKET XmlScriptParser parse: Got script
[&lt;?xml version='1.0' encoding='UTF-8'?>

&lt;publish sessionId='sessionId:127.0.0.2-null-1151873723867' requestId='name:115187001' type='R'>

 &lt;qos>
  &lt;key oid='Woodlogging'/>
  &lt;rcvTimestamp nanos='1151873925214000000'/>
 &lt;isPublish/>
 &lt;/qos>
&lt;/publish>
]
</pre>

   </example>

   <configuration where="server">
      <h2>Server side configuration</h2>

      <p>Note: If you have additional SOCKET plugins registered,
      you need to replace <b>socket</b> with the name you gave to your plugin, for example <b>socket_ssl</b>,
      and the property would be for example <i>plugin/socket_ssl/compress/type=zlib:stream</i>.</p>

      <p>Note: If you configure a property in <tt>xmlBlasterPlugins.xml</tt> the scope is
      already inside the specific plugin and you need to leave away the prefix <b>plugin/socket</b> and
      for example directly write <b>responseTimeout</b>.<br />
      On command line or in <tt>xmlBlaster.properties</tt> however, the scope is global and you need
      to write the complete name like <b>plugin/socket_ssl/responseTimeout</b>.</p>

      <table border="1">
         <tr>
            <th>Property</th>
            <th>Default / Example</th>
            <th>Description</th>
            <th>Impl</th>
         </tr>

         <tr>
            <td>plugin/socket/hostname</td>
            <td>localhost</td>
            <td>Specify a hostname where the SOCKET server runs
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/port</td>
            <td>7607</td>
            <td>The SOCKET server port
                </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/localHostname</td>
            <td>localhost</td>
            <td>The local address the socket is bound to. 
            Usually this is dynamically choosen by your operating system and you don't need
            to specify it.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/localPort</td>
            <td>8900</td>
            <td>The local port the socket is bound to.
                Default is -1 and the operating system chooses an arbitrary port.
                </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/startUdpListener</td>
            <td>false</td>
            <td>Start a UDP datagram listener socket on server side
                </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/useUdpForOneway</td>
            <td>false</td>
            <td>When configured to true the updateOneway() callback will be send
                as UDP datagram. UDP does not guarantee delivery or correct sequence
                but has a significant smaller latency.
                </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/updateResponseTimeout</td>
            <td>forever</td>
            <td>When the <code>update()</code> callback method is invoked we wait the given time [milli-seconds] on a response, the value must be
            bigger than zero, use Integer.MAX_VALUE for an unlimited setting.<br />
            The response is the return value or an exception for method invocations which
            are not marked oneway.<br />
            On timeout an exception is thrown which leads on server side to a dead message
            (depending on the installed error handler).
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/pingResponseTimeout</td>
            <td>60000</td>
            <td>When the <code>ping()</code> method is invoked we wait the given time [milli-seconds] on a response, 
            the value must be bigger than zero, it defaults to one minute.<br />
            The response is the return value or an exception for method invocations which
            are not marked oneway.<br />
            On timeout an exception is thrown which leads on server side to a dead message
            (depending on the installed error handler).
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/SoTimeout</td>
            <td>0</td>
            <td>How long we max. block on InputStream.read(). Please leave this value
                0, as we should block on input stream indefinitely to receive a new message.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/SoLingerTimeout</td>
            <td>0</td>
            <td>If the socket is closed, how long shall we try to deliver unsent data from the socket stack.
            Please leave this value 0, as other settings could block the socket close() operation
            in the kernel (usually the timeout is 10-20 minutes, and your specific setting is ignored).
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/backlog</td>
            <td>50</td>
            <td>Socket queue size for incoming connection request
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/threadPrio</td>
            <td>NORM_PRIORITY = 5</td>
            <td>The priority 1=min - 10=max of the listener thread
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/SSL</td>
            <td>false</td>
            <td>true enables SSL support on server or client socket.
            If the server side plugin has switched on SSL it will accept
            only SSL clients. To have SSL and non-SSL SOCKET connections
            you need to register two SOCKET plugins in xmlBlasterPlugins.xml
            which listen on different ports, for details see the example section.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/needClientAuth</td>
            <td>false</td>
            <td>Set to 'true' if the client needs to be authenticated by the server.
            In such a case you need to add the clients public key to the servers trustStore.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/keyStore</td>
            <td>''</td>
            <td>The path of your SSL keystore file containing the private key.
            This option is needed for every server or client instance containing its private key.
            You can specify an absolute path like <tt>/tmp/myKeyStore</tt> or a relative name
            like <tt>myKeyStore</tt>, in the latter example the current directory is checked.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/keyStorePassword</td>
            <td>''</td>
            <td>The password of your keystore file.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/trustStore</td>
            <td>''</td>
            <td>The path of your SSL truststore or keystore file containing the remote certificate.
            This option is needed on server side if you want to connect two xmlBlaster cluster nodes via SSL SOCKET.
            The xmlBlaster server is simultaneously a SLL SOCKET client and connects to the remote node.
            To do this the certificate of the remote node must be imported to the local keystore file
            or to a separate certificate store. Add this name here.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/trustStorePassword</td>
            <td>''</td>
            <td>The password of your keystore file.
                If none is found we fall back to the server side <tt>plugin/socket/keyStorePassword</tt> setting if set.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/compress/type</td>
            <td>''</td>
            <td>Valid values are:
              <ul>
                <li>'' disables compression (default)</li>
                <li>'zlib:stream' compresses whole stream</li>
                <li>'zlib' only compresses flushed chunks bigger than 'compress/minSize' bytes</li>
              </ul>
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/compress/minSize</td>
            <td>0</td>
            <td>Compress message bigger than given bytes, see above
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>parserClass</td>
            <td>org.xmlBlaster.util.xbformat.XbfParser</td>
            <td>The default chooses the above described formatting over socket.
            It is however possible to force the xmlBlaster scripting markup to be send directly over
            the socket wire, each script needs to be ended by one zero byte, please set
            <code>parserClass=org.xmlBlaster.util.xbformat.XmlScriptParser</code> and
            <code>isNullTerminated=true</code> in this case.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>isNullTerminated</td>
            <td>false</td>
            <td>This setting is only useful if you switch to xmlBlaster scripting markup (see 'parserClass' setting).
            In this case you need to set <code>isNullTerminated=true</code> to get a zero byte between the script messages sent
            over the socket. 
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>dump[socket]</td>
            <td>false</td>
            <td>true switches message dump on
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
      </table>
   </configuration>
   <configuration where="client">
      <h2>Additional client side configuration</h2>
      <p>The Java socket implementation on client side supports
         the same properties as the server (we reuse the same implementation).
         You need to add the "dispatch/callback/" or "dispatch/connection/" prefix
         to the property key.<br />
         You have these additional features on client side:
      </p>
      <table border="1">
         <tr>
            <th>Property</th>
            <th>Default</th>
            <th>Description</th>
            <th>Impl</th>
         </tr>

         <tr>
            <td>dispatch/callback/plugin/<br />socket/multiThreaded</td>
            <td>true</td>
            <td>
            <ul>
              <li>true: Incoming callback requests (the update() method) are dispatched to one thread per request.<br />
               This avoids deadlocks if you call recursively the server - calling for example in the
               update() thread a publish() or subscribe() would otherwise deadlock (publishOneway() is OK).<br />
               Note that oneway message updates (method updateOneway()) are not guaranteed to be in sequence, since one thread on
               client side may overtake another one.<br />
               The update() variant with return value is still guaranteed to keep the sequence
               since xmlBlaster on server side uses exactly one thread per client to callback.
              </li>
              <li>false: There is only one thread for callbacks on client side, this guarantees that even your updateOneway() method
              receives the messages in strict order.<br />
              On the other hand you can't call any non-oneway xmlBlaster method in the update() body since this would deadlock.
              </li>
            </ul>
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
         <tr>
            <td>dispatch/callback/plugin/<br />socket/invokerThreadPrio</td>
            <td>NORM_PRIORITY = 5</td>
            <td>
              The priority of the client side callback thread which calls your update method.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
         <tr>
            <td>dispatch/callback/plugin/<br />socket/threadPrio</td>
            <td>NORM_PRIORITY = 5</td>
            <td>The priority 1=min - 10=max of the client side callback server listener thread
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/responseTimeout</td>
            <td>forever</td>
            <td>When methods like <code>connect()</code>, <code>publish</code>, <code>subscribe</code> etc.
            is invoked we wait the given time [milli-seconds] on a response, the value must be
            bigger than zero, use Integer.MAX_VALUE for an unlimited setting.<br />
            The response is the return value or an exception for method invocations which
            are not marked oneway.<br />
            On timeout an exception is thrown which is forwarded to your client code.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/trustStore</td>
            <td>''</td>
            <td>The path of your SSL keystore file. Use the java utility keytool.
                If none is found we fall back to the server side <tt>plugin/socket/keyStore</tt> setting if set.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/trustStorePassword</td>
            <td>''</td>
            <td>The password of your keystore file.
                If none is found we fall back to the server side <tt>plugin/socket/keyStorePassword</tt> setting if set.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

         <tr>
            <td>plugin/socket/findStoreInXmlBlasterSearchPath</td>
            <td>false</td>
            <td>The default lookup of the keyStore and trustStore files is directly on the harddisk with the name given.
            Switching to <tt>true</tt> enables the xmlBlaster lookup strategy as described in requirement
            <a href="http://www.xmlblaster.org/xmlBlaster/doc/requirements/util.property.html" target="others">util.property</a>.<br />
            <b>Note:</b>This feature is only available for JDK 1.4 and above.
            The xmlBlaster relase 1.0 has not enabled it since it needs to support JDK 1.3, please recompile xmlBlaster
            with '<tt>build -Dneed.JDK.14=true clean all</tt>' to have this feature.<br />
            <b>Note:</b>This flag is currently only available on java client side (for example for WebStart clients 
            containing the keyStore/trustStore in a jar file and accessing it via the CLASSPATH).
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>

      </table>
   </configuration>
   <todo type="HTML">
   <ol>
      <li>
      Currently the server has implemented a one thread/client approach.
      This doesn't scale very well with thousands of clients -
      we need to code another SOCKET protocol plugin based on the non-blocking nio framework since JDK 1.4 (http://java.sun.com/developer/technicalArticles/releases/nio/).
      </li>
      <!-- 
      Different encodings on client and server side could be a problem, test with 
      java -Dfile.encoding=ISO8859_1 ... or System.setProperty("file.encoding","Cp850");
      -->
   </ol>
   <h2>Note on UDP datagram usage</h2>
   <p>Each network in the Internet is characterised by a Maximum Transmission Unit (MTU),
      which defines the largest datagram which can be sent on that network.
      Whilst the total length of a datagram can (in theory) be up to 64 KB,
      "real world" MTU limits usually mean datagrams are smaller 1500 bytes in total length.
   </p>
   <p>Currently we have configured MAX_PACKET_SIZE = 10*1024</p>
   </todo>
   <see type="REQ">protocol</see>
   <see type="REQ">client.c.socket</see>
   <see type="REQ">client.cpp.socket</see>
   <see type="API">org.xmlBlaster.protocol.util.xbformat.Parser</see>
   <see type="API">org.xmlBlaster.protocol.socket.SocketDriver</see>
   <see type="API">org.xmlBlaster.protocol.socket.SocketUrl</see>
   <see type="CODE" lang="C">socket/XmlBlasterAccessUnparsed.c</see>
   <see type="INTERNET" label="SSL tutorial">http://java.sun.com/developer/JDCTechTips/2004/tt0914.html#2</see>
   <see type="INTERNET" label="SSL reference guide">http://java.sun.com/j2se/1.4.2/docs/guide/security/jsse/JSSERefGuide.html</see>
   <see type="INTERNET" label="Java compression jzlib">http://www.jcraft.com/jzlib/</see>
   <see type="INTERNET" label="C compression zlib">http://www.gzip.org/zlib/</see>
   <see type="INTERNET" label="xmlBlasterPlugins.xml">http://www.xmlBlaster.org/xmlBlaster/config/xmlBlasterPlugins.xml.template</see>
   <see type="INTERNET" label="xmlBlaster.properties">http://www.xmlBlaster.org/xmlBlaster/config/xmlBlaster.properties.template</see>
   <author>xmlBlaster@marcelruff.info</author>
   <date>2002 02 12</date>
   <revision>$Revision: 1.56 $</revision>
   <testcase status="OPEN">
      <name>-</name>
      <comment>-</comment>
      <test tool="SUITE">testsuite.</test>
   </testcase>
</requirement>

