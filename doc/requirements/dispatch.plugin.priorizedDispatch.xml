<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE requirement SYSTEM "requirement.dtd">

<requirement id='dispatch.plugin.priorizedDispatch' type='NEW' prio='MEDIUM' status='CLOSED'>
   <topic>XmlBlaster provides a plugin to control message delivery to remote destinations</topic>
   <description>
      <p>
      XmlBlaster has a plugin interface to control the dispatcher framework. This
      requirement describes one plugin realization which is free configurable to control
      message delivery to remote destinations.
      </p>
      <p>
      Probably you should first read the <i>delivery.control.plugin</i> requirement (see link below) to
      get the big picture and then proceed with the description of this specific plugin implementation.
      </p>
      <h3>What can this plugin do for you?</h3>
      <p>
      The plugin supports a set of actions. You configure the wanted behaviour
      and switch the actions by sending specific status messages to the plugin.
      The supported actions are:
      </p>

      <ol>
         <li><b>send</b>  Messages are send as without a plugin by passing them to the dispatcher framework
         </li>
         <li><b>queue</b>  Messages are retained in a local 'hold back queue'
         </li>
         <li><b>destroy</b>  Messages are destroyed
         </li>
         <li><b>notifySender</b>  The publisher is notified about the current action, this action
         is only possible in combination with one of the first three actions
         </li>
      </ol>

      <br />
      <p>
      Now lets have a look at how the plugin works:
      </p>
      <br />

      <img src="PriorizedDispatchPluginOverview.gif" border="0" title="XmlBlaster priorized dispatch plugin overview" alt="Overview of the priorized dispatch plugin" />

      <br />
      <p>
      Messages are coming from the left hand side into the xmlBlaster core. If a client has subscribed
      to messages they will be forwarded to the callback queue (see green arrows in drawing).
      Naturally the dispatcher framework would take the messages out of the callback queue
      and deliver them directly to the client with whichever protocol the client wished (like CORBA or XmlRpc).
      </p>
      <p>
      As the client has requested to use the plugin in his connectQos, all messages from the callback queue are
      intercepted by the plugin and inspected. Depending on the configuration of the plugin
      the messages are handled as requested. The possible actions are <i>send</i>, <i>queue</i> and
      <i>destroy</i> each of them can have the additional action <i>notifySender</i>.
      </p>
      <p>
      Messages which are <i>queued</i> are put in a plugin owned <i>hold back queue</i> (see red arrow). If the 
      plugin state later changes to send them they are flushed back to the update queue to be delivered.
      You may wonder why they are not directly put into the dispatcher - this is because of the dispatcher
      framework does not know anything about our plugin implementation details, that the plugin has implemented an own queue.
      The dispatcher only knows how to deal with its update queue.
      </p>
      <p>
      There are two events which change the plugin state, and further a new
      plugin configuration command reconfigures the complete plugin on the fly.
      </p>

      <ol>
         <li><b>Connection state events from the dispatcher</b><br />
           The dispatcher notifies the plugin about the current state of the connection.
           This is a normal Java method invocation telling the plugin if the
           remote connection is <i>ALIVE</i>, <i>POLLING</i> or <i>DEAD</i>.
           Such events have precedence over the 'status messages' because they
           reflect the real situation whereas the 'status messages' giving additional
           hints about the connection.
         </li>
         <li><b>Status messages from a remote source</b><br />
           Any normal xmlBlaster client can send status messages describing the current
           connection which results in the configured actions.
           The source of such a message could by a manual operation of an administrator
           or automically generated by a router or a PLC device. 
         </li>
         <li><b>New plugin configuration</b><br />
           An administrator can send the plugin a new configuration in hot operation. This
           reconfigures the plugin on the fly. The configuration is sent by a command message
           setting a system property.
         </li>
      </ol>

      <h3>How to configure the plugin?</h3>
      <p>
      The priority of each message is the input parameter of the decision.
      The priority of a message is set by a publisher when sending the message away.
      Depending on the priority and the current state of the dispatcher connection and
      of the state messages an action is chosen. The action determines what happens to
      the message - if it is queued, destroyed or forwarded.
      </p>
      <p>
      The following drawing shows a typical configuration:
      </p>
      <br />

      <img src="PriorizedDispatchPluginConfiguration.gif" border="0" title="XmlBlaster priorized dispatch plugin configuration" alt="Configuration of the priorized dispatch plugin" />

      <br />
      <h3>How does my status message look like?</h3>
      <p>
      In the above configuration you have specified the message oid to <i>_bandwidth.status</i>
      and the content to e.g. <i>64k</i>.
      The plugin parses your above configuration and automatically subscribes to all
      given message oids.<br />
      So you need to send a message with that oid and content to xmlBlaster. The plugin
      receives the message and switches its state.
      </p>
      <p>
      If your client is a router, you can for example write a little perl script which
      queries the router state and publishes this as a status message to xmlBlaster.
      </p>

      <br />
      <h3>How does the notify message look like?</h3>
      <p>
      If you have configured an <i>action='...,notifySender'</i>, all publishers
      of message which match this action receive a PtP notification message.
      </p>
      <p>
      This notification message has the same message oid as the published message
      but an empty content. You can query the reason for this PtP message in
      the state of the update() QoS:
      </p>
      <pre>
&lt;qos>
   &lt;state id='queue' 
         info='Notification about special message treatment
               in plugin DispatchPlugin[Priority][1],
               dispatcher state=64k'/>
   &lt;sender>_PriorizedDispatchPlugin&lt;/sender>
   &lt;priority>6&lt;/priority>
&lt;/qos>
 
      </pre>

      <br />
      <h3>Can i use many plugins simultanous?</h3>
      <p>
      You can load this plugin multiple times in one xmlBlaster server instance,
      where every instance has another configuration.
      The clients connecting xmlBlaster
      can choose which variant they want to use.
      </p>
      <p>
      Note that one client can not use more than one plugin at the same time.
      </p>

      <br />
      <h3>How does a client choose a plugin for its connection?</h3>
      <p>
      A client can use the configuration parameter <i>DispatchPlugin.defaultPlugin</i>
      on command line or in its xmlBlaster.properties file. Please see configuration section
      below.
      </p>
      <p>
      In normal cases, the user will configure the plugin during login with the ConnectQos
      the connect() QoS XML string (requirement <a href="interface.connect.html" target="others">interface.connect</a>):
      </p>
<pre class="BORDER">
   &lt;connect>
     &lt;qos>
       ...
       &lt;queue relating='callback'>
          &lt;callback ... <font color="red">dispatchPlugin='Priority,1.0'></font>
         ...
         &lt;/callback>
       &lt;/queue>
     &lt;/qos>
  &lt;/connect>
</pre>
      <p>
      or as a Java code fragment:
      </p>
<pre class="BORDER">
  this.connectQos = new ConnectQos(glob, name, passwd);

  CallbackAddress cbAddress = new CallbackAddress(glob);
  cbAddress.setDelay(1000L);      // retry connecting every 4 sec
  cbAddress.setRetries(-1);       // -1 == forever
  cbAddress.setPingInterval(5000L); // ping every 4 seconds
  cbAddress.setDispatchPlugin("Priority,1.0");  // Activate plugin for callback only
  this.connectQos.addCallbackAddress(cbAddress);
  </pre>
   </description>

   <example lang="Java" type="HTML">

      <p>
For coding examples please look into the testsuite, links are provided below.
      </p>
   </example>

   <configuration where="server">
      <p>
      These parameters allow to configure the dispatch plugin.
      </p>
      <table border="1">
         <tr>
            <th>Property</th>
            <th>Default</th>
            <th>Description</th>
            <th>Implemented</th>
         </tr>

         <tr>
            <td>DispatchPlugin[Priority][1]</td>
            <td>org.xmlBlaster.util.dispatch.\<br />
            plugins.prio.PriorizedDispatchPlugin</td>
            <td>Loads the plugin on the server side</td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
         <tr>
            <td>DispatchPlugin[Priority][2]</td>
            <td>org.xmlBlaster.util.dispatch.\<br />
            plugins.prio.PriorizedDispatchPlugin</td>
            <td>Loads the same plugin on the server side under a different name.
            You can configure this plugin differently. Do this as often you as like.</td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
         <tr>
            <td>DispatchPlugin/defaultPlugin</td>
            <td>Priority,1</td>
            <td>Activates the plugin 1 as default for all connections if not 
            the client overwrites this default.<br />
            You can do this on client side to configure your client to use a plugin.
            On the server side loading the plugin as default is usually not wanted.<br />
            Setting it to 'undef' deactivates a default plugin for all connections
            which is the default
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
         <tr>
            <td>dispatch/callback/DispatchPlugin/defaultPlugin</td>
            <td>Priority,1</td>
            <td>Activates the plugin 1 as default for all callback connections if not 
            the client overwrites this default.<br />
            You can do this on client side to configure your xmlBlaster callback connection
            to be called back using this plugin.
            On the server side loading the plugin as default is usually not wanted.<br />
            Setting it to 'undef' deactivates a default plugin for all callback connections
            which is the default.
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
         <tr>
            <td>PriorizedDispatchPlugin/config</td>
            <td><pre>&lt;msgDispatch ...<br />...</pre></td>
            <td>The XML default configuration string for the plugin
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
         <tr>
            <td>PriorizedDispatchPlugin/config[Priority,2]</td>
            <td><pre>&lt;msgDispatch ...<br />...</pre></td>
            <td>A specific XML configuration string for the plugin 'Priority,2'
            </td>
            <td><img src="ok.gif" border="0" alt="yes" /></td>
         </tr>
      </table>
   </configuration>

   <see type="API">org.xmlBlaster.util.dispatch.plugins.prio.PriorizedDispatchPlugin</see>
   <see type="API">org.xmlBlaster.util.dispatch.plugins.prio.ConfigurationParser</see>
   <see type="API">org.xmlBlaster.util.dispatch.DispatchManager</see>
   <see type="API">org.xmlBlaster.util.plugin.I_Plugin</see>
   <see type="REQ">dispatch.control.plugin</see>
   <author>xmlBlaster@marcelruff.info</author>
   <date>2002 11 08</date>
   <revision>$Revision: 1.3 $</revision>
   <testcase status="CLOSED">
      <name>-</name>
      <comment>-</comment>
      <test tool="SUITE">org.xmlBlaster.test.dispatch.ConfigurationParserTest</test>
      <test tool="SUITE">org.xmlBlaster.test.dispatch.TestPriorizedDispatchPlugin</test>
      <test tool="SUITE">org.xmlBlaster.test.dispatch.TestPriorizedDispatchWithLostCallback</test>
   </testcase>
</requirement>

