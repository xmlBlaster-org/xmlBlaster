/*------------------------------------------------------------------------------
Name:      SubscribeQos.cpp
Project:   xmlBlaster.org
Copyright: xmlBlaster.org, see xmlBlaster-LICENSE file
------------------------------------------------------------------------------*/

/**
 * This class encapsulates the QoS of an subscribe() request.
 * <p />
 * see xmlBlaster/src/dtd/XmlQoS.xml
 * @see org.xmlBlaster.util.qos.QueryQosData
 * @see org.xmlBlaster.util.qos.QueryQosSaxFactory
 * @see <a href="http://www.xmlblaster.org/xmlBlaster/doc/requirements/interface.subscribe.html">subscribe interface</a>
 */

#include <client/qos/SubscribeQos.h>
#include <util/Global.h>

using namespace std;
using namespace org::xmlBlaster::util;
using namespace org::xmlBlaster::util::qos;

namespace org { namespace xmlBlaster { namespace client { namespace qos {

SubscribeQos::SubscribeQos(Global& global) : GetQos(global)
{
   ME = "SubscribeQos";
}

SubscribeQos::SubscribeQos(Global& global, const QueryQosData& data)
   : GetQos(global, data)
{
   ME = "SubscribeQos";
}

SubscribeQos::SubscribeQos(const SubscribeQos& qos) : GetQos(qos)
{
}

SubscribeQos& SubscribeQos::operator =(const SubscribeQos& qos)
{
   data_ = qos.data_;
   return *this;
}


/**
 * Do we want to have an initial update on subscribe if the message
 * exists already?
 *
 * @return true if initial update wanted
 *         false if only updates on new publishes are sent
 * @see <a href="http://www.xmlBlaster.org/xmlBlaster/doc/requirements/engine.qos.subscribe.initialUpdate.html">The engine.qos.subscribe.initialUpdate requirement</a>
 */
void SubscribeQos::setWantInitialUpdate(bool initialUpdate)
{
   data_.setWantInitialUpdate(initialUpdate);
}

/**
 * Do we want the callback messages of this subscription as oneway with <tt>updateOneway()</tt> or with
 * the acknowledged <tt>update()</tt>.
 * @param updateOneway Defaults to false.
 * @see <a href="http://www.xmlBlaster.org/xmlBlaster/doc/requirements/interface.subscribe.html">The interface.subscribe requirement</a>
 * @see QueryQosData#setWantUpdateOneway(boolean)
 */
void SubscribeQos::setWantUpdateOneway(bool updateOneway)
{
   data_.setWantUpdateOneway(updateOneway);
}

/**
 * Are multiple subscribes allowed?
 * Defaults to true.
 * @return true Multiple subscribes deliver multiple updates
 *         false Ignore more than one subscribes on same oid
 */
void SubscribeQos::setMultiSubscribe(bool multiSubscribe)
{
   data_.setMultiSubscribe(multiSubscribe);
}

/**
 * false Inhibit the delivery of messages to myself if i have published it.
 */
void SubscribeQos::setWantLocal(bool local)
{
   data_.setWantLocal(local);
}

void SubscribeQos::setWantNotify(bool notifyOnErase)
{
   data_.setWantNotify(notifyOnErase);
}

/**
 * Force the identifier (unique handle) for this subscription.
 * Usually you let the identifier be generated by xmlBlaster.
 * @see <a href="http://www.xmlBlaster.org/xmlBlaster/doc/requirements/engine.qos.subscribe.id.html">The engine.qos.subscribe.id requirement</a>
 */
void SubscribeQos::setSubscriptionId(const string& subscriptionId) const
{
   data_.setSubscriptionId(subscriptionId);
}

bool SubscribeQos::hasSubscriptionId() const {
  return data_.getSubscriptionId().size() > 0;
}

bool SubscribeQos::getMultiSubscribe() const {
  return data_.getMultiSubscribe();
}

std::string SubscribeQos::generateSubscriptionId(org::xmlBlaster::util::SessionNameRef sessionName, const org::xmlBlaster::client::key::SubscribeKey& subscribeKey)
{
      if (sessionName->getPubSessionId() > 0 || !getMultiSubscribe()) {
         // This key is assured to be the same on client restart
         // a previous subscription in the server will have the same subscriptionId
         // Benefit: If on client restart we are queueing the returned faked subscriptionId will
         // match the later used one of the xmlBlaster server. We can easily use the subscriptionId
         // as a key in client code hashtable to dispatch update() messages
         // Note: multiSubscribe==false allows max one subscription on a topic, even it has
         // different mime query plugins (the latest wins)
         std::string url = subscribeKey.getUrl();
         url = StringTrim::replaceAll(url, "'", "&apos;"); // to have valid xml (<subscribe id='bla'/>
         setSubscriptionId(Constants::SUBSCRIPTIONID_PREFIX +
                               sessionName->getRelativeName(true) + "-" +
                               url);
      }
      else {
         TimestampFactory& factory = TimestampFactory::getInstance();
         Timestamp timestamp = factory.getTimestamp();
         setSubscriptionId(Constants::SUBSCRIPTIONID_PREFIX +
                               /* immutableId is also relativeName */
                               /*is global_.getImmutableId() better than sessionName?? */
                               sessionName->getRelativeName(true) + "-" +
                               lexical_cast<string>(timestamp));
      }
      return data_.getSubscriptionId();
   }

void SubscribeQos::setPersistent(bool persistent) {
   data_.setPersistent(persistent);
}

}}}} // namespace

